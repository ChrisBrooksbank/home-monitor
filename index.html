<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üè† 28 Barn Green - Home Monitor</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&family=Baloo+2:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Fredoka', sans-serif;
            background: linear-gradient(180deg, #87CEEB 0%, #98D8E8 30%, #F0E68C 70%, #90EE90 100%);
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            position: relative;
            overflow: hidden;
        }

        /* Floating clouds */
        .cloud {
            position: absolute;
            background: white;
            border-radius: 100px;
            opacity: 0.7;
            animation: float-cloud 30s infinite linear;
        }

        .cloud::before,
        .cloud::after {
            content: '';
            position: absolute;
            background: white;
            border-radius: 100px;
        }

        .cloud1 {
            width: 100px;
            height: 40px;
            top: 10%;
            left: -150px;
        }

        .cloud1::before {
            width: 50px;
            height: 50px;
            top: -25px;
            left: 10px;
        }

        .cloud1::after {
            width: 60px;
            height: 40px;
            top: -15px;
            right: 10px;
        }

        .cloud2 {
            width: 120px;
            height: 50px;
            top: 20%;
            left: -200px;
            animation-delay: -15s;
        }

        .cloud2::before {
            width: 60px;
            height: 60px;
            top: -30px;
            left: 15px;
        }

        .cloud2::after {
            width: 70px;
            height: 50px;
            top: -20px;
            right: 15px;
        }

        @keyframes float-cloud {
            to {
                left: calc(100% + 200px);
            }
        }

        /* Birds */
        .bird {
            position: absolute;
            font-size: 24px;
            animation: fly 20s infinite ease-in-out;
            opacity: 0.6;
        }

        .bird1 {
            top: 15%;
            left: -50px;
        }

        .bird2 {
            top: 25%;
            left: -80px;
            animation-delay: -7s;
        }

        @keyframes fly {
            to {
                left: calc(100% + 100px);
                top: calc(15% + 50px);
            }
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(15px);
            border-radius: 30px;
            padding: 20px;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.2);
            max-width: 1400px;
            max-height: 95vh;
            width: 100%;
            position: relative;
            z-index: 1;
            border: 4px solid rgba(255, 255, 255, 0.8);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .container::-webkit-scrollbar {
            width: 10px;
        }

        .container::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 10px;
        }

        .container::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
        }

        .container::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #5568d3 0%, #653a8a 100%);
        }

        h1 {
            text-align: center;
            background: linear-gradient(135deg, #FF6B9D 0%, #FFA07A 50%, #FFD700 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
            font-size: 2em;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            animation: wiggle 3s ease-in-out infinite;
        }

        @keyframes wiggle {
            0%, 100% { transform: rotate(-1deg); }
            50% { transform: rotate(1deg); }
        }

        .last-update {
            text-align: center;
            color: #666;
            margin-bottom: 15px;
            font-size: 0.85em;
        }

        .house-container {
            position: relative;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        svg {
            width: 100%;
            height: auto;
            filter: drop-shadow(0 10px 30px rgba(0, 0, 0, 0.2));
        }

        .room-fill {
            transition: all 0.4s ease;
        }

        .room-fill:hover {
            filter: brightness(1.15);
            transform: scale(1.02);
        }

        .temp-badge, .thermometer {
            cursor: pointer;
        }

        .temp-badge:hover, .thermometer:hover {
            animation: massive-shake 0.5s ease-in-out infinite;
        }

        @keyframes massive-shake {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            10% { transform: translate(-10px, -10px) rotate(-8deg); }
            20% { transform: translate(10px, -8px) rotate(8deg); }
            30% { transform: translate(-8px, 10px) rotate(-6deg); }
            40% { transform: translate(12px, 5px) rotate(10deg); }
            50% { transform: translate(-12px, -5px) rotate(-10deg); }
            60% { transform: translate(8px, 8px) rotate(6deg); }
            70% { transform: translate(-10px, 10px) rotate(-8deg); }
            80% { transform: translate(10px, -10px) rotate(8deg); }
            90% { transform: translate(-8px, -8px) rotate(-6deg); }
        }

        .temp-display {
            font-family: 'Baloo 2', cursive;
            font-size: 28px;
            font-weight: 700;
            animation: bounce 2s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px;
            border-radius: 20px;
            color: white;
            text-align: center;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
            transition: all 0.3s ease;
            border: 3px solid rgba(255, 255, 255, 0.3);
        }

        .stat-card:hover {
            transform: translateY(-8px) rotate(2deg);
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.5);
        }

        .stat-label {
            font-size: 0.75em;
            opacity: 0.95;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: 700;
            font-family: 'Baloo 2', cursive;
        }

        .refresh-btn {
            display: block;
            margin: 15px auto 0;
            padding: 10px 30px;
            background: linear-gradient(135deg, #FF6B9D 0%, #FFA07A 100%);
            color: white;
            border: none;
            border-radius: 50px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(255, 107, 157, 0.4);
            font-family: 'Fredoka', sans-serif;
            border: 3px solid rgba(255, 255, 255, 0.5);
        }

        .refresh-btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 40px rgba(255, 107, 157, 0.6);
        }

        .refresh-btn:active {
            transform: translateY(-2px) scale(1.02);
        }

        .refresh-btn.loading {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            100% { transform: rotate(360deg); }
        }

        /* Sparkle animation */
        .sparkle {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
        }

        .sparkle-star {
            position: absolute;
            font-size: 20px;
            animation: sparkle-float 1s ease-out forwards;
        }

        @keyframes sparkle-float {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(0) rotate(0deg);
            }
            50% {
                opacity: 1;
                transform: translate(var(--tx), var(--ty)) scale(1.5) rotate(180deg);
            }
            100% {
                opacity: 0;
                transform: translate(calc(var(--tx) * 2), calc(var(--ty) * 2)) scale(0) rotate(360deg);
            }
        }

        @keyframes sparkle {
            0%, 100% { opacity: 0; transform: scale(0); }
            50% { opacity: 1; transform: scale(1); }
        }

        /* Glow effect for updated temps */
        .temp-updated {
            animation: temp-glow 1s ease-out;
        }

        @keyframes temp-glow {
            0%, 100% { filter: drop-shadow(0 0 0 transparent); }
            50% { filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.8)); }
        }

        /* Graph styles */
        .graph-container {
            margin-top: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .graph-title {
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
            font-size: 1.5em;
            font-weight: 700;
        }

        #temp-graph {
            width: 100%;
            height: auto;
            filter: drop-shadow(0 5px 15px rgba(0, 0, 0, 0.1));
        }

        .graph-line {
            fill: none;
            stroke-width: 3;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .graph-point {
            transition: all 0.3s ease;
        }

        .graph-point:hover {
            r: 8;
            filter: drop-shadow(0 0 10px currentColor);
        }

        @keyframes draw-line {
            to {
                stroke-dashoffset: 0;
            }
        }

        /* Motion detection animations */
        .motion-pulse {
            animation: motion-pulse 1.5s ease-out infinite;
        }

        @keyframes motion-pulse {
            0% {
                r: 15;
                opacity: 0.6;
            }
            50% {
                r: 25;
                opacity: 0.3;
            }
            100% {
                r: 15;
                opacity: 0.6;
            }
        }

        .motion-person {
            animation: motion-bounce 0.6s ease-in-out infinite alternate;
        }

        /* Monkey shake animation */
        .monkey-shake {
            animation: monkey-shake 2s ease-in-out infinite;
            transform-origin: center;
        }

        @keyframes monkey-shake {
            0%, 100% { transform: rotate(-3deg) translateX(-1px); }
            25% { transform: rotate(3deg) translateX(1px); }
            50% { transform: rotate(-3deg) translateX(-1px); }
            75% { transform: rotate(2deg) translateX(0.5px); }
        }

        /* Fade out animation */
        .monkey-fadeout {
            animation: fadeout 2s ease-out forwards;
        }

        @keyframes fadeout {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes motion-bounce {
            0% {
                transform: translateY(0);
            }
            100% {
                transform: translateY(-3px);
            }
        }

        /* Collapsible sections */
        .section-header {
            cursor: pointer;
            user-select: none;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .section-header:hover {
            transform: scale(1.02);
            filter: brightness(1.1);
        }

        .section-arrow {
            transition: transform 0.3s ease;
            font-size: 0.8em;
        }

        .section-arrow.collapsed {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.5s ease, opacity 0.3s ease, margin 0.3s ease;
            opacity: 1;
        }

        .collapsible-content.collapsed {
            max-height: 0;
            opacity: 0;
            margin: 0 !important;
        }
    </style>
</head>
<body>
    <!-- Clouds -->
    <div class="cloud cloud1"></div>
    <div class="cloud cloud2"></div>

    <!-- Birds -->
    <div class="bird bird1">üê¶</div>
    <div class="bird bird2">üïäÔ∏è</div>

    <div class="container">
        <h1>üè° 28 Barn Green üå°Ô∏è</h1>
        <div class="last-update" id="lastUpdate">Loading magical temperatures...</div>

        <div class="house-container">
            <svg viewBox="0 0 1000 650" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <!-- Gradients -->
                    <linearGradient id="skyGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" style="stop-color:#87CEEB;stop-opacity:0.3" />
                        <stop offset="100%" style="stop-color:#E0F6FF;stop-opacity:0.1" />
                    </linearGradient>

                    <linearGradient id="roofGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#FF6B6B;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#C92A2A;stop-opacity:1" />
                    </linearGradient>

                    <linearGradient id="wallGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#FFE66D;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#FFC93C;stop-opacity:1" />
                    </linearGradient>

                    <linearGradient id="grassGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" style="stop-color:#7AE582;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#4CAF50;stop-opacity:1" />
                    </linearGradient>

                    <!-- Room gradients - temperature based -->
                    <linearGradient id="coldGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#A8DADC;stop-opacity:0.9" />
                        <stop offset="100%" style="stop-color:#1D3557;stop-opacity:0.9" />
                    </linearGradient>

                    <linearGradient id="coolGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#B8F2E6;stop-opacity:0.9" />
                        <stop offset="100%" style="stop-color:#5FA9A1;stop-opacity:0.9" />
                    </linearGradient>

                    <linearGradient id="warmGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#FFD6A5;stop-opacity:0.9" />
                        <stop offset="100%" style="stop-color:#FFADAD;stop-opacity:0.9" />
                    </linearGradient>

                    <linearGradient id="hotGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#FF9999;stop-opacity:0.9" />
                        <stop offset="100%" style="stop-color:#FF6B6B;stop-opacity:0.9" />
                    </linearGradient>

                    <!-- Patterns -->
                    <pattern id="brickPattern" x="0" y="0" width="40" height="20" patternUnits="userSpaceOnUse">
                        <rect width="40" height="20" fill="none"/>
                        <rect width="18" height="8" x="1" y="1" fill="rgba(200,100,100,0.3)" stroke="rgba(150,50,50,0.4)" stroke-width="0.5"/>
                        <rect width="18" height="8" x="21" y="11" fill="rgba(200,100,100,0.3)" stroke="rgba(150,50,50,0.4)" stroke-width="0.5"/>
                    </pattern>

                    <filter id="shadow">
                        <feDropShadow dx="0" dy="6" stdDeviation="8" flood-opacity="0.4"/>
                    </filter>

                    <filter id="glow">
                        <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                        <feMerge>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                </defs>

                <!-- Sky background -->
                <rect width="1000" height="600" fill="url(#skyGradient)"/>

                <!-- Sun -->
                <g id="sun" style="animation: spin 30s linear infinite; transform-origin: 880px 100px;">
                    <circle cx="880" cy="100" r="50" fill="#FFD700" opacity="0.8" filter="url(#glow)"/>
                    <circle cx="880" cy="100" r="40" fill="#FFA500"/>
                </g>

                <!-- Moon (hidden during day) -->
                <g id="moon" style="display: none;">
                    <circle cx="850" cy="120" r="45" fill="#F0F0F0" filter="url(#glow)"/>
                    <circle cx="860" cy="115" r="40" fill="#E8E8E8"/>
                    <!-- Craters -->
                    <circle cx="845" cy="110" r="8" fill="#D0D0D0" opacity="0.6"/>
                    <circle cx="870" cy="125" r="6" fill="#D0D0D0" opacity="0.5"/>
                    <circle cx="855" cy="135" r="5" fill="#D0D0D0" opacity="0.7"/>
                </g>

                <!-- Stars (hidden during day) -->
                <g id="stars" style="display: none;">
                    <circle cx="100" cy="50" r="2" fill="white" opacity="0.9">
                        <animate attributeName="opacity" values="0.9;0.3;0.9" dur="3s" repeatCount="indefinite"/>
                    </circle>
                    <circle cx="200" cy="80" r="1.5" fill="white" opacity="0.8">
                        <animate attributeName="opacity" values="0.8;0.4;0.8" dur="2.5s" repeatCount="indefinite" begin="0.5s"/>
                    </circle>
                    <circle cx="350" cy="40" r="2" fill="white" opacity="0.9">
                        <animate attributeName="opacity" values="0.9;0.2;0.9" dur="4s" repeatCount="indefinite" begin="1s"/>
                    </circle>
                    <circle cx="500" cy="70" r="1.5" fill="white" opacity="0.7">
                        <animate attributeName="opacity" values="0.7;0.3;0.7" dur="3.5s" repeatCount="indefinite" begin="1.5s"/>
                    </circle>
                    <circle cx="650" cy="45" r="2" fill="white" opacity="0.9">
                        <animate attributeName="opacity" values="0.9;0.4;0.9" dur="3s" repeatCount="indefinite" begin="0.8s"/>
                    </circle>
                    <circle cx="750" cy="90" r="1.5" fill="white" opacity="0.8">
                        <animate attributeName="opacity" values="0.8;0.3;0.8" dur="2.8s" repeatCount="indefinite" begin="2s"/>
                    </circle>
                    <circle cx="150" cy="120" r="1" fill="white" opacity="0.7">
                        <animate attributeName="opacity" values="0.7;0.2;0.7" dur="3.2s" repeatCount="indefinite" begin="0.3s"/>
                    </circle>
                    <circle cx="300" cy="110" r="1.5" fill="white" opacity="0.8">
                        <animate attributeName="opacity" values="0.8;0.4;0.8" dur="3.8s" repeatCount="indefinite" begin="1.2s"/>
                    </circle>
                    <circle cx="450" cy="130" r="1" fill="white" opacity="0.7">
                        <animate attributeName="opacity" values="0.7;0.3;0.7" dur="2.7s" repeatCount="indefinite" begin="1.8s"/>
                    </circle>
                    <circle cx="600" cy="100" r="1.5" fill="white" opacity="0.9">
                        <animate attributeName="opacity" values="0.9;0.3;0.9" dur="3.3s" repeatCount="indefinite" begin="0.6s"/>
                    </circle>
                    <circle cx="800" cy="55" r="2" fill="white" opacity="0.8">
                        <animate attributeName="opacity" values="0.8;0.2;0.8" dur="4.2s" repeatCount="indefinite" begin="2.5s"/>
                    </circle>
                    <circle cx="920" cy="75" r="1.5" fill="white" opacity="0.9">
                        <animate attributeName="opacity" values="0.9;0.4;0.9" dur="3.6s" repeatCount="indefinite" begin="1.3s"/>
                    </circle>
                </g>

                <!-- Grass -->
                <ellipse cx="500" cy="620" rx="600" ry="80" fill="url(#grassGradient)"/>
                <ellipse cx="300" cy="595" rx="200" ry="35" fill="#69B578" opacity="0.6"/>
                <ellipse cx="700" cy="605" rx="250" ry="40" fill="#69B578" opacity="0.6"/>

                <!-- Pixel Art UK Semi-Detached House -->
                <g>
                    <!-- Attached neighbor house (left side, partial) -->
                    <rect x="20" y="250" width="80" height="350" fill="#8B4513" stroke="#654321" stroke-width="2"/>
                    <rect x="20" y="250" width="80" height="350" fill="url(#brickPattern)" opacity="0.8"/>

                    <!-- Main house structure - brick exterior -->
                    <rect x="100" y="200" width="800" height="400" fill="#A0522D" stroke="#654321" stroke-width="4"/>

                    <!-- Pixel brick pattern overlay -->
                    <defs>
                        <pattern id="pixelBrick" x="0" y="0" width="32" height="16" patternUnits="userSpaceOnUse">
                            <rect width="32" height="16" fill="#A0522D"/>
                            <rect x="0" y="0" width="15" height="7" fill="#8B4513" stroke="#654321" stroke-width="0.5"/>
                            <rect x="16" y="0" width="15" height="7" fill="#8B4513" stroke="#654321" stroke-width="0.5"/>
                            <rect x="8" y="8" width="15" height="7" fill="#8B4513" stroke="#654321" stroke-width="0.5"/>
                            <rect x="24" y="8" width="7" height="7" fill="#8B4513" stroke="#654321" stroke-width="0.5"/>
                            <rect x="0" y="8" width="7" height="7" fill="#8B4513" stroke="#654321" stroke-width="0.5"/>
                        </pattern>
                    </defs>
                    <rect x="100" y="200" width="800" height="400" fill="url(#pixelBrick)" opacity="0.6"/>

                    <!-- Pitched roof - pixel style -->
                    <polygon points="80,200 500,80 920,200" fill="#7D0000" stroke="#4A0000" stroke-width="3"/>
                    <!-- Roof tiles effect -->
                    <line x1="500" y1="80" x2="80" y2="200" stroke="#5A0000" stroke-width="2"/>
                    <line x1="500" y1="80" x2="920" y2="200" stroke="#5A0000" stroke-width="2"/>
                    <line x1="290" y1="140" x2="80" y2="200" stroke="#5A0000" stroke-width="1"/>
                    <line x1="710" y1="140" x2="920" y2="200" stroke="#5A0000" stroke-width="1"/>

                    <!-- Chimney stack - pixel style -->
                    <rect x="700" y="100" width="48" height="100" fill="#8B4513" stroke="#654321" stroke-width="2"/>
                    <rect x="700" y="100" width="48" height="100" fill="url(#pixelBrick)" opacity="0.7"/>
                    <rect x="692" y="92" width="64" height="16" fill="#654321"/>

                    <!-- Chimney pots -->
                    <rect x="708" y="76" width="12" height="20" fill="#654321" stroke="#000" stroke-width="1"/>
                    <rect x="728" y="76" width="12" height="20" fill="#654321" stroke="#000" stroke-width="1"/>

                    <!-- Smoke (pixelated) -->
                    <rect x="710" y="60" width="8" height="8" fill="#D3D3D3" opacity="0.5">
                        <animate attributeName="opacity" values="0.5;0.2;0.5" dur="2s" repeatCount="indefinite"/>
                    </rect>
                    <rect x="718" y="52" width="8" height="8" fill="#D3D3D3" opacity="0.4">
                        <animate attributeName="opacity" values="0.4;0.1;0.4" dur="2s" repeatCount="indefinite" begin="0.5s"/>
                    </rect>
                    <rect x="730" y="62" width="8" height="8" fill="#D3D3D3" opacity="0.5">
                        <animate attributeName="opacity" values="0.5;0.2;0.5" dur="2s" repeatCount="indefinite" begin="1s"/>
                    </rect>

                    <!-- Pixel art windows on exterior (first floor) -->
                    <g id="exterior-windows-first">
                        <rect x="140" y="240" width="48" height="56" fill="#87CEEB" stroke="#2C1507" stroke-width="2"/>
                        <line x1="164" y1="240" x2="164" y2="296" stroke="#2C1507" stroke-width="2"/>
                        <line x1="140" y1="268" x2="188" y2="268" stroke="#2C1507" stroke-width="2"/>

                        <rect x="300" y="240" width="48" height="56" fill="#87CEEB" stroke="#2C1507" stroke-width="2"/>
                        <line x1="324" y1="240" x2="324" y2="296" stroke="#2C1507" stroke-width="2"/>
                        <line x1="300" y1="268" x2="348" y2="268" stroke="#2C1507" stroke-width="2"/>

                        <rect x="460" y="240" width="48" height="56" fill="#87CEEB" stroke="#2C1507" stroke-width="2"/>
                        <line x1="484" y1="240" x2="484" y2="296" stroke="#2C1507" stroke-width="2"/>
                        <line x1="460" y1="268" x2="508" y2="268" stroke="#2C1507" stroke-width="2"/>

                        <rect x="620" y="240" width="48" height="56" fill="#87CEEB" stroke="#2C1507" stroke-width="2"/>
                        <line x1="644" y1="240" x2="644" y2="296" stroke="#2C1507" stroke-width="2"/>
                        <line x1="620" y1="268" x2="668" y2="268" stroke="#2C1507" stroke-width="2"/>

                        <rect x="780" y="240" width="48" height="56" fill="#87CEEB" stroke="#2C1507" stroke-width="2"/>
                        <line x1="804" y1="240" x2="804" y2="296" stroke="#2C1507" stroke-width="2"/>
                        <line x1="780" y1="268" x2="828" y2="268" stroke="#2C1507" stroke-width="2"/>
                    </g>

                    <!-- Pixel art windows on exterior (ground floor) -->
                    <g id="exterior-windows-ground">
                        <rect x="320" y="420" width="56" height="72" fill="#87CEEB" stroke="#2C1507" stroke-width="2"/>
                        <line x1="348" y1="420" x2="348" y2="492" stroke="#2C1507" stroke-width="2"/>
                        <line x1="320" y1="456" x2="376" y2="456" stroke="#2C1507" stroke-width="2"/>

                        <rect x="520" y="420" width="56" height="72" fill="#87CEEB" stroke="#2C1507" stroke-width="2"/>
                        <line x1="548" y1="420" x2="548" y2="492" stroke="#2C1507" stroke-width="2"/>
                        <line x1="520" y1="456" x2="576" y2="456" stroke="#2C1507" stroke-width="2"/>

                        <rect x="740" y="420" width="56" height="72" fill="#87CEEB" stroke="#2C1507" stroke-width="2"/>
                        <line x1="768" y1="420" x2="768" y2="492" stroke="#2C1507" stroke-width="2"/>
                        <line x1="740" y1="456" x2="796" y2="456" stroke="#2C1507" stroke-width="2"/>
                    </g>

                    <!-- FIRST FLOOR ROOMS (y: 200-350) -->
                    <!-- Main Bedroom (above Hall) -->
                    <rect x="100" y="200" width="160" height="150" fill="rgba(255,182,193,0.5)" stroke="#CC9933" stroke-width="3"/>
                    <text x="180" y="225" text-anchor="middle" font-size="14" font-weight="700" font-family="Fredoka" fill="#8B4513">Main Bedroom</text>

                    <!-- Landing -->
                    <rect x="260" y="200" width="160" height="150" fill="rgba(255,218,185,0.5)" stroke="#CC9933" stroke-width="3"/>
                    <text x="340" y="225" text-anchor="middle" font-size="14" font-weight="700" font-family="Fredoka" fill="#8B4513">Landing</text>
                    <!-- Stairs icon -->
                    <rect x="310" y="260" width="60" height="6" fill="rgba(139,69,19,0.6)"/>
                    <rect x="310" y="270" width="60" height="6" fill="rgba(139,69,19,0.6)"/>
                    <rect x="310" y="280" width="60" height="6" fill="rgba(139,69,19,0.6)"/>
                    <rect x="310" y="290" width="60" height="6" fill="rgba(139,69,19,0.6)"/>

                    <!-- Home Office -->
                    <rect x="420" y="200" width="160" height="150" fill="rgba(173,216,230,0.5)" stroke="#CC9933" stroke-width="3"/>
                    <text x="500" y="225" text-anchor="middle" font-size="14" font-weight="700" font-family="Fredoka" fill="#8B4513">Home Office</text>

                    <!-- Bathroom -->
                    <rect x="580" y="200" width="160" height="150" fill="rgba(152,251,152,0.5)" stroke="#CC9933" stroke-width="3"/>
                    <text x="660" y="225" text-anchor="middle" font-size="14" font-weight="700" font-family="Fredoka" fill="#8B4513">Bathroom</text>

                    <!-- Guest Bedroom -->
                    <rect x="740" y="200" width="160" height="150" fill="rgba(221,160,221,0.5)" stroke="#CC9933" stroke-width="3"/>
                    <text x="820" y="225" text-anchor="middle" font-size="14" font-weight="700" font-family="Fredoka" fill="#8B4513">Guest Bedroom</text>

                    <!-- GROUND FLOOR ROOMS (y: 350-600) -->
                    <!-- Hall (left, with door) -->
                    <rect x="100" y="350" width="200" height="250" fill="rgba(152,216,211,0.5)" stroke="#CC9933" stroke-width="4"/>
                    <text x="200" y="380" text-anchor="middle" font-size="16" font-weight="700" font-family="Fredoka" fill="#8B4513">Hall</text>
                    <!-- Front Door - pixel art style -->
                    <rect x="160" y="500" width="80" height="100" fill="#4A2511" stroke="#2C1507" stroke-width="3"/>
                    <!-- Door panels -->
                    <rect x="168" y="508" width="64" height="40" fill="#5D3116" stroke="#2C1507" stroke-width="1"/>
                    <rect x="168" y="552" width="64" height="40" fill="#5D3116" stroke="#2C1507" stroke-width="1"/>
                    <!-- Door handle -->
                    <circle cx="215" cy="560" r="4" fill="#FFD700" stroke="#CC9900" stroke-width="1"/>
                    <!-- Door letterbox -->
                    <rect x="180" y="530" width="40" height="6" fill="#2C1507"/>

                    <!-- House Number Plaque -->
                    <rect x="125" y="520" width="30" height="35" fill="#F5F5DC" stroke="#8B7355" stroke-width="2" rx="3"/>
                    <text x="140" y="542" text-anchor="middle" font-size="20" font-weight="700" font-family="Georgia, serif" fill="#2C1507">28</text>

                    <!-- Lounge -->
                    <rect x="300" y="350" width="200" height="250" fill="rgba(244,164,96,0.5)" stroke="#CC9933" stroke-width="4"/>
                    <text x="400" y="380" text-anchor="middle" font-size="16" font-weight="700" font-family="Fredoka" fill="#8B4513">Lounge</text>

                    <!-- Kitchen -->
                    <rect x="500" y="350" width="200" height="250" fill="rgba(255,179,71,0.5)" stroke="#CC9933" stroke-width="4"/>
                    <text x="600" y="380" text-anchor="middle" font-size="16" font-weight="700" font-family="Fredoka" fill="#8B4513">Kitchen</text>

                    <!-- Extension (right) -->
                    <rect x="700" y="350" width="200" height="250" fill="rgba(152,216,200,0.5)" stroke="#CC9933" stroke-width="4"/>
                    <text x="800" y="380" text-anchor="middle" font-size="16" font-weight="700" font-family="Fredoka" fill="#8B4513">Extension</text>
                </g>

                <!-- Light indicators will be dynamically added here by JavaScript -->
                <g id="light-indicators-container"></g>

                <!-- Motion indicators will be dynamically added here by JavaScript -->
                <g id="motion-indicators-container"></g>

                <!-- Thermometers will be dynamically added here by JavaScript -->
                <g id="thermometers-container"></g>

                <!-- Outdoor area (OUTSIDE the house) -->
                <g id="outdoor-area" transform="translate(30, 420)">
                    <!-- Tree -->
                    <rect x="10" y="70" width="20" height="90" rx="5" fill="#8B4513"/>
                    <circle cx="20" cy="60" r="45" fill="#2ECC71" opacity="0.8"/>
                    <circle cx="8" cy="45" r="38" fill="#27AE60" opacity="0.8"/>
                    <circle cx="32" cy="45" r="38" fill="#27AE60" opacity="0.8"/>

                    <!-- Narnia-style Lamppost -->
                    <g id="outdoor-lamppost">
                        <!-- Base -->
                        <rect x="140" y="140" width="30" height="8" fill="#2C3E50" rx="2"/>
                        <rect x="145" y="148" width="20" height="8" fill="#34495E" rx="1"/>

                        <!-- Post -->
                        <rect x="150" y="65" width="10" height="83" fill="#34495E" rx="2"/>
                        <rect x="148" y="65" width="14" height="4" fill="#2C3E50"/>

                        <!-- Ornate top piece -->
                        <rect x="148" y="50" width="14" height="15" fill="#2C3E50" rx="1"/>

                        <!-- Lamp housing (glass panels) -->
                        <g id="lamp-housing">
                            <!-- Top -->
                            <polygon points="155,35 165,50 145,50" fill="#8B4513"/>

                            <!-- Glass panels (will change based on on/off) -->
                            <rect x="148" y="50" width="4" height="12" fill="#1a1a1a" opacity="0.3" id="lamp-panel-1"/>
                            <rect x="158" y="50" width="4" height="12" fill="#1a1a1a" opacity="0.3" id="lamp-panel-2"/>
                            <rect x="150" y="50" width="10" height="12" fill="#1a1a1a" opacity="0.2" id="lamp-panel-center"/>

                            <!-- Light bulb inside (will glow when on) -->
                            <circle cx="155" cy="56" r="6" fill="#666" id="lamp-bulb"/>

                            <!-- Frame lines -->
                            <rect x="148" y="50" width="14" height="12" fill="none" stroke="#2C3E50" stroke-width="1.5"/>
                            <line x1="152" y1="50" x2="152" y2="62" stroke="#2C3E50" stroke-width="1"/>
                            <line x1="158" y1="50" x2="158" y2="62" stroke="#2C3E50" stroke-width="1"/>
                        </g>

                        <!-- Decorative scrollwork -->
                        <path d="M 155 65 Q 145 68 145 73" fill="none" stroke="#2C3E50" stroke-width="1.5"/>
                        <path d="M 155 65 Q 165 68 165 73" fill="none" stroke="#2C3E50" stroke-width="1.5"/>
                    </g>

                    <!-- Outdoor thermometer will be added here by JavaScript -->
                    <g id="outdoor-thermometer-container"></g>
                </g>

                <!-- Flowers in garden -->
                <g transform="translate(150, 590)">
                    <circle cx="0" cy="0" r="7" fill="#FF69B4"/>
                    <circle cx="25" cy="4" r="7" fill="#FF1493"/>
                    <circle cx="50" cy="-2" r="7" fill="#FF69B4"/>
                    <rect x="-2" y="0" width="2.5" height="25" fill="#228B22"/>
                    <rect x="23" y="4" width="2.5" height="20" fill="#228B22"/>
                    <rect x="48" y="-2" width="2.5" height="27" fill="#228B22"/>
                </g>

                <g transform="translate(750, 598)">
                    <circle cx="0" cy="0" r="7" fill="#FFD700"/>
                    <circle cx="22" cy="2" r="7" fill="#FFA500"/>
                    <circle cx="44" cy="-1" r="7" fill="#FFD700"/>
                    <rect x="-2" y="0" width="2.5" height="23" fill="#228B22"/>
                    <rect x="20" y="2" width="2.5" height="20" fill="#228B22"/>
                    <rect x="42" y="-1" width="2.5" height="25" fill="#228B22"/>
                </g>
            </svg>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-label">üè† Average Indoor</div>
                <div class="stat-value" id="avg-temp">--¬∞C</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">üî• Warmest Room</div>
                <div class="stat-value" id="max-temp">--¬∞C</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">‚ùÑÔ∏è Coolest Room</div>
                <div class="stat-value" id="min-temp">--¬∞C</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">üìä Temp Range</div>
                <div class="stat-value" id="range-temp">--¬∞C</div>
            </div>
        </div>

        <button class="refresh-btn" onclick="loadTemperatures()" id="refreshBtn">
            üîÑ Refresh Temps!
        </button>

        <!-- Fun Action Buttons -->
        <div style="display: flex; gap: 10px; justify-content: center; margin-top: 15px; flex-wrap: wrap;">
            <button class="refresh-btn" onclick="redAlert()" id="redAlertBtn" style="background: linear-gradient(135deg, #FF0000 0%, #8B0000 100%);">
                üö® Red Alert
            </button>
            <button class="refresh-btn" onclick="partyMode()" id="partyBtn" style="background: linear-gradient(135deg, #FF00FF 0%, #00FFFF 100%);">
                üéâ Party Mode
            </button>
            <button class="refresh-btn" onclick="discoMode()" id="discoBtn" style="background: linear-gradient(135deg, #FFD700 0%, #FF1493 100%);">
                üï∫ Disco
            </button>
            <button class="refresh-btn" onclick="waveEffect()" id="waveBtn" style="background: linear-gradient(135deg, #4169E1 0%, #1E90FF 100%);">
                üåä Wave
            </button>
            <button class="refresh-btn" onclick="sunsetMode()" id="sunsetBtn" style="background: linear-gradient(135deg, #FF6B35 0%, #FF8E53 100%);">
                üåÖ Sunset
            </button>
        </div>

        <!-- Sensor Details Panel -->
        <div class="graph-container" style="margin-top: 20px;">
            <h2 class="graph-title section-header" onclick="toggleSection('sensor-details-content', 'sensor-arrow')">
                <span class="section-arrow collapsed" id="sensor-arrow">‚ñº</span>
                üì° Sensor Details
            </h2>
            <div id="sensor-details-content" class="collapsible-content collapsed">
                <div id="sensor-details" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; padding: 15px;">
                    <div style="text-align: center; color: #999; padding: 20px;">Loading sensor data...</div>
                </div>
            </div>
        </div>

        <!-- Motion Detection Log -->
        <div class="graph-container" style="margin-top: 20px;">
            <h2 class="graph-title section-header" onclick="toggleSection('motion-log-content', 'motion-arrow')">
                <span class="section-arrow collapsed" id="motion-arrow">‚ñº</span>
                üö∂ 48-Hour Motion Detection Log
            </h2>
            <div id="motion-log-content" class="collapsible-content collapsed">
                <div id="motion-log" style="max-height: 300px; overflow-y: auto; padding: 15px; background: #f9f9f9; border-radius: 10px; font-family: 'Courier New', monospace; font-size: 13px;">
                    <div style="text-align: center; color: #999; padding: 20px;">Loading motion history...</div>
                </div>
                <div style="text-align: center; margin-top: 10px; font-size: 12px; color: #666;">
                    <span id="motion-log-count">0</span> events in last 48 hours
                </div>
            </div>
        </div>

        <!-- Temperature Graph -->
        <div class="graph-container">
            <h2 class="graph-title">üìà 24-Hour Temperature History</h2>
            <svg id="temp-graph" viewBox="0 0 1200 400" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <linearGradient id="gridGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" style="stop-color:#f0f0f0;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#ffffff;stop-opacity:1" />
                    </linearGradient>
                </defs>
                <!-- Background -->
                <rect width="1200" height="400" fill="url(#gridGradient)" rx="10"/>

                <!-- Grid lines will be added by JavaScript -->
                <g id="grid-lines"></g>

                <!-- Graph lines will be added by JavaScript -->
                <g id="graph-lines"></g>

                <!-- Axes -->
                <line x1="50" y1="350" x2="1150" y2="350" stroke="#ccc" stroke-width="2"/>
                <line x1="50" y1="50" x2="50" y2="350" stroke="#ccc" stroke-width="2"/>

                <!-- Labels will be added by JavaScript -->
                <g id="axis-labels"></g>
                <g id="legend"></g>
            </svg>
        </div>
    </div>

    <script src="config.js"></script>
    <script>
        const BRIDGE_IP = HUE_CONFIG.BRIDGE_IP;
        const USERNAME = HUE_CONFIG.USERNAME;

        const sensorMapping = {
            // First Floor
            'landing': 'temp-landing',
            'main bedroom': 'temp-main-bedroom',
            'guest room': 'temp-guest-bedroom',
            'Hue temperature sensor 1': 'temp-office',  // Home Office
            'bathroom': 'temp-bathroom',
            // Ground Floor
            'Hall': 'temp-hall',
            'lounge': 'temp-lounge',
            'ExtensionDimmer': 'temp-extension',
            'guest room': 'temp-guest-bedroom',
            'KitchenSensor': 'temp-kitchen',
            // Outdoor
            'Hue outdoor temp. sensor 1': 'temp-outdoor'
        };

        const roomColors = {
            // First Floor
            'landing': '#FF6B9D',
            'main bedroom': '#FFB6C1',
            'guest room': '#DDA0DD',
            'Hue temperature sensor 1': '#87CEEB',
            'bathroom': '#4ECDC4',
            // Ground Floor
            'Hall': '#95E1D3',
            'lounge': '#F4A460',
            'ExtensionDimmer': '#98D8C8',
            'KitchenSensor': '#FFB347',
            // Outdoor
            'Hue outdoor temp. sensor 1': '#7AE582'
        };

        const roomNames = {
            // First Floor
            'landing': 'Landing',
            'main bedroom': 'Main Bedroom',
            'guest room': 'Guest Bedroom',
            'Hue temperature sensor 1': 'Home Office',
            'bathroom': 'Bathroom',
            // Ground Floor
            'Hall': 'Hall',
            'lounge': 'Lounge',
            'ExtensionDimmer': 'Extension',
            'KitchenSensor': 'Kitchen',
            // Outdoor
            'Hue outdoor temp. sensor 1': 'Outdoor'
        };

        // Light bulb mapping to rooms (will be populated dynamically)
        const lightMapping = {};

        // Store light states for each room
        const roomLights = {
            'Main Bedroom': [],
            'Guest Bedroom': [],
            'Landing': [],
            'Home Office': [],
            'Bathroom': [],
            'Lounge': [],
            'Hall': [],
            'Extension': [],
            'Kitchen': [],
            'Outdoor': []
        };

        // Track previous light states for announcements
        const previousLightStates = {};

        // Store motion sensor states
        const motionSensors = {
            'Outdoor': { detected: false, lastUpdated: null, previousDetected: false },
            'Hall': { detected: false, lastUpdated: null, previousDetected: false },
            'Landing': { detected: false, lastUpdated: null, previousDetected: false },
            'Bathroom': { detected: false, lastUpdated: null, previousDetected: false }
        };

        // Motion detection history (48 hours)
        let motionHistory = [];

        // Initialize motion history from localStorage
        function initMotionHistory() {
            const stored = localStorage.getItem('motionHistory');
            if (stored) {
                motionHistory = JSON.parse(stored);
                // Clean old data (older than 48 hours)
                const now = Date.now();
                const twoDaysAgo = now - (48 * 60 * 60 * 1000);
                motionHistory = motionHistory.filter(entry => entry.time > twoDaysAgo);
                localStorage.setItem('motionHistory', JSON.stringify(motionHistory));
            }
            updateMotionLogDisplay();
        }

        // Log a motion detection event
        function logMotionEvent(room) {
            const now = Date.now();
            motionHistory.push({
                time: now,
                room: room
            });

            // Keep only last 48 hours
            const twoDaysAgo = now - (48 * 60 * 60 * 1000);
            motionHistory = motionHistory.filter(entry => entry.time > twoDaysAgo);

            // Save to localStorage
            localStorage.setItem('motionHistory', JSON.stringify(motionHistory));

            // Update display
            updateMotionLogDisplay();
        }

        // Update the motion log display
        function updateMotionLogDisplay() {
            const logContainer = document.getElementById('motion-log');
            const countDisplay = document.getElementById('motion-log-count');

            if (!logContainer) return;

            // Count display
            countDisplay.textContent = motionHistory.length;

            if (motionHistory.length === 0) {
                logContainer.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">No motion events recorded yet</div>';
                return;
            }

            // Sort by most recent first
            const sortedHistory = [...motionHistory].sort((a, b) => b.time - a.time);

            // Group by date
            const groupedByDate = {};
            sortedHistory.forEach(entry => {
                const date = new Date(entry.time);
                const dateKey = date.toLocaleDateString();
                if (!groupedByDate[dateKey]) {
                    groupedByDate[dateKey] = [];
                }
                groupedByDate[dateKey].push(entry);
            });

            // Build HTML
            let html = '';
            for (const [dateKey, events] of Object.entries(groupedByDate)) {
                html += `<div style="margin-bottom: 15px;">`;
                html += `<div style="font-weight: bold; color: #667eea; margin-bottom: 8px; font-family: 'Fredoka', sans-serif;">üìÖ ${dateKey}</div>`;

                events.forEach(entry => {
                    const date = new Date(entry.time);
                    const timeStr = date.toLocaleTimeString();
                    const roomEmoji = {
                        'Outdoor': 'üå≥',
                        'Hall': 'üö™',
                        'Landing': 'ü™ú',
                        'Bathroom': 'üöø'
                    };
                    const emoji = roomEmoji[entry.room] || 'üö∂';

                    // Calculate how long ago
                    const now = Date.now();
                    const diff = now - entry.time;
                    const hours = Math.floor(diff / (60 * 60 * 1000));
                    const minutes = Math.floor((diff % (60 * 60 * 1000)) / (60 * 1000));
                    let ago = '';
                    if (hours > 0) {
                        ago = `${hours}h ${minutes}m ago`;
                    } else if (minutes > 0) {
                        ago = `${minutes}m ago`;
                    } else {
                        ago = 'just now';
                    }

                    html += `<div style="padding: 6px 10px; margin: 4px 0; background: white; border-radius: 6px; border-left: 3px solid #667eea; display: flex; justify-content: space-between; align-items: center;">`;
                    html += `<span>${emoji} <strong>${entry.room}</strong> - ${timeStr}</span>`;
                    html += `<span style="color: #999; font-size: 11px;">${ago}</span>`;
                    html += `</div>`;
                });

                html += `</div>`;
            }

            logContainer.innerHTML = html;

            // Auto-scroll to top (most recent)
            logContainer.scrollTop = 0;
        }

        // Voice announcement function for motion
        function announceMotion(room) {
            // Use Web Speech API for local voice announcement
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance();

                // Different messages for different locations
                const messages = {
                    'Outdoor': 'Motion detected outside',
                    'Hall': 'Motion detected in the hall',
                    'Landing': 'Motion detected on the landing',
                    'Bathroom': 'Motion detected in the bathroom'
                };

                utterance.text = messages[room] || `Motion detected in ${room}`;
                utterance.rate = 1.1; // Slightly faster for urgency
                utterance.pitch = 1.0;
                utterance.volume = 1.0;

                // Cancel any ongoing speech and speak
                window.speechSynthesis.cancel();
                window.speechSynthesis.speak(utterance);
            } else {
                // Fallback: play a beep sound if speech not available
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = 800;
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            }
        }

        // Voice announcement function for lights
        function announceLight(room, isOn) {
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance();

                const action = isOn ? 'on' : 'off';
                const roomName = room.toLowerCase();

                utterance.text = `${room} light turned ${action}`;
                utterance.rate = 1.0;
                utterance.pitch = 1.0;
                utterance.volume = 0.8;

                // Don't cancel ongoing speech, queue it instead
                window.speechSynthesis.speak(utterance);

                console.log(`üí° Announced: ${room} light ${action}`);
            }
        }

        // Temperature history storage
        let tempHistory = {};

        function initTempHistory() {
            const stored = localStorage.getItem('tempHistory');
            if (stored) {
                tempHistory = JSON.parse(stored);
                // Clean old data (older than 24 hours)
                const now = Date.now();
                const oneDayAgo = now - (24 * 60 * 60 * 1000);
                for (let room in tempHistory) {
                    tempHistory[room] = tempHistory[room].filter(entry => entry.time > oneDayAgo);
                }
            } else {
                for (let room in sensorMapping) {
                    tempHistory[room] = [];
                }
            }
        }

        function saveTempData(room, temp) {
            const now = Date.now();
            if (!tempHistory[room]) {
                tempHistory[room] = [];
            }
            tempHistory[room].push({ time: now, temp: parseFloat(temp) });

            // Keep only last 24 hours
            const oneDayAgo = now - (24 * 60 * 60 * 1000);
            tempHistory[room] = tempHistory[room].filter(entry => entry.time > oneDayAgo);

            localStorage.setItem('tempHistory', JSON.stringify(tempHistory));
        }

        function drawGraph() {
            const graphLines = document.getElementById('graph-lines');
            const gridLines = document.getElementById('grid-lines');
            const axisLabels = document.getElementById('axis-labels');
            const legend = document.getElementById('legend');

            // Clear existing elements
            graphLines.innerHTML = '';
            gridLines.innerHTML = '';
            axisLabels.innerHTML = '';
            legend.innerHTML = '';

            const now = Date.now();
            const oneDayAgo = now - (24 * 60 * 60 * 1000);

            // Graph dimensions
            const width = 1100;
            const height = 300;
            const marginLeft = 50;
            const marginBottom = 50;

            // Find min/max temps across all rooms
            let minTemp = Infinity;
            let maxTemp = -Infinity;

            for (let room in tempHistory) {
                tempHistory[room].forEach(entry => {
                    if (entry.temp < minTemp) minTemp = entry.temp;
                    if (entry.temp > maxTemp) maxTemp = entry.temp;
                });
            }

            if (minTemp === Infinity) {
                minTemp = 0;
                maxTemp = 30;
            } else {
                minTemp = Math.floor(minTemp) - 2;
                maxTemp = Math.ceil(maxTemp) + 2;
            }

            // Draw grid lines
            const tempRange = maxTemp - minTemp;
            for (let i = 0; i <= 5; i++) {
                const temp = minTemp + (tempRange * i / 5);
                const y = 350 - (temp - minTemp) / tempRange * height;

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', marginLeft);
                line.setAttribute('y1', y);
                line.setAttribute('x2', marginLeft + width);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#e0e0e0');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('stroke-dasharray', '5,5');
                gridLines.appendChild(line);

                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', marginLeft - 10);
                label.setAttribute('y', y + 5);
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('font-size', '12');
                label.setAttribute('fill', '#666');
                label.textContent = temp.toFixed(1) + '¬∞C';
                axisLabels.appendChild(label);
            }

            // Draw time labels (every 4 hours)
            for (let i = 0; i <= 6; i++) {
                const time = oneDayAgo + (24 * 60 * 60 * 1000 * i / 6);
                const x = marginLeft + (width * i / 6);
                const date = new Date(time);
                const hours = date.getHours().toString().padStart(2, '0');

                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', 370);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('font-size', '12');
                label.setAttribute('fill', '#666');
                label.textContent = hours + ':00';
                axisLabels.appendChild(label);
            }

            // Draw lines for each room
            let legendY = 70;
            for (let room in tempHistory) {
                const data = tempHistory[room];
                if (data.length < 2) continue;

                const color = roomColors[room] || '#999';
                const points = [];

                data.forEach(entry => {
                    const x = marginLeft + ((entry.time - oneDayAgo) / (24 * 60 * 60 * 1000)) * width;
                    const y = 350 - ((entry.temp - minTemp) / tempRange) * height;
                    points.push(`${x},${y}`);
                });

                const pathData = 'M' + points.join(' L');
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('class', 'graph-line');
                path.setAttribute('stroke', color);

                // Calculate path length for animation
                const pathLength = path.getTotalLength();
                path.style.strokeDasharray = pathLength;
                path.style.strokeDashoffset = pathLength;
                path.style.animation = `draw-line 2s ease-out forwards`;

                graphLines.appendChild(path);

                // Draw points
                data.forEach(entry => {
                    const x = marginLeft + ((entry.time - oneDayAgo) / (24 * 60 * 60 * 1000)) * width;
                    const y = 350 - ((entry.temp - minTemp) / tempRange) * height;

                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', 4);
                    circle.setAttribute('fill', color);
                    circle.setAttribute('class', 'graph-point');
                    circle.style.opacity = 0;
                    circle.style.animation = `fade-in 0.5s ease-out ${2 + (x / width) * 0.5}s forwards`;

                    const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                    const date = new Date(entry.time);
                    title.textContent = `${roomNames[room]}: ${entry.temp}¬∞C at ${date.toLocaleTimeString()}`;
                    circle.appendChild(title);

                    graphLines.appendChild(circle);
                });

                // Legend
                const legendRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                legendRect.setAttribute('x', 900);
                legendRect.setAttribute('y', legendY - 10);
                legendRect.setAttribute('width', 20);
                legendRect.setAttribute('height', 4);
                legendRect.setAttribute('fill', color);
                legend.appendChild(legendRect);

                const legendText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                legendText.setAttribute('x', 930);
                legendText.setAttribute('y', legendY);
                legendText.setAttribute('font-size', '14');
                legendText.setAttribute('font-weight', '600');
                legendText.setAttribute('fill', '#333');
                legendText.setAttribute('font-family', 'Fredoka');
                legendText.textContent = roomNames[room];
                legend.appendChild(legendText);

                legendY += 25;
            }

            // Add fade-in animation for points
            if (!document.getElementById('fade-in-style')) {
                const style = document.createElement('style');
                style.id = 'fade-in-style';
                style.textContent = `
                    @keyframes fade-in {
                        to { opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
            }
        }

        // Room positions for thermometers (bulb positioned inside each room)
        const roomPositions = {
            // First Floor (y: 200-350) - bulbs near bottom of rooms
            'temp-main-bedroom': { x: 180, y: 220 },
            'temp-landing': { x: 340, y: 220 },
            'temp-office': { x: 500, y: 220 },
            'temp-bathroom': { x: 660, y: 220 },
            'temp-guest-bedroom': { x: 820, y: 220 },
            // Ground Floor (y: 350-600) - bulbs in middle/lower section
            'temp-hall': { x: 200, y: 420 },
            'temp-lounge': { x: 400, y: 420 },
            'temp-kitchen': { x: 600, y: 420 },
            'temp-extension': { x: 800, y: 420 },
            // Outdoor (relative to outdoor-area transform)
            'temp-outdoor': { x: 60, y: 10, isOutdoor: true }
        };

        function getTemperatureColor(temp) {
            if (temp < 10) return '#4169E1';  // Royal Blue - Cold
            if (temp < 15) return '#00CED1';  // Dark Turquoise - Cool
            if (temp < 20) return '#32CD32';  // Lime Green - Comfortable
            if (temp < 25) return '#FFA500';  // Orange - Warm
            return '#FF4500';  // Orange Red - Hot
        }

        function createThermometer(elementId, temp, roomName) {
            const position = roomPositions[elementId];
            if (!position) return null;

            const ns = 'http://www.w3.org/2000/svg';
            const group = document.createElementNS(ns, 'g');
            group.setAttribute('class', 'thermometer');
            group.setAttribute('data-room', elementId);

            // Thermometer dimensions
            const tubeWidth = 24;
            const tubeHeight = 80;
            const bulbRadius = 16;

            // Background (glass tube)
            const tube = document.createElementNS(ns, 'rect');
            tube.setAttribute('x', 0);
            tube.setAttribute('y', 0);
            tube.setAttribute('width', tubeWidth);
            tube.setAttribute('height', tubeHeight);
            tube.setAttribute('rx', 12);
            tube.setAttribute('fill', 'rgba(255, 255, 255, 0.9)');
            tube.setAttribute('stroke', '#666');
            tube.setAttribute('stroke-width', '2');
            tube.setAttribute('filter', 'url(#shadow)');
            group.appendChild(tube);

            // Bulb
            const bulb = document.createElementNS(ns, 'circle');
            bulb.setAttribute('cx', tubeWidth / 2);
            bulb.setAttribute('cy', tubeHeight + bulbRadius - 4);
            bulb.setAttribute('r', bulbRadius);
            bulb.setAttribute('fill', 'rgba(255, 255, 255, 0.9)');
            bulb.setAttribute('stroke', '#666');
            bulb.setAttribute('stroke-width', '2');
            bulb.setAttribute('filter', 'url(#shadow)');
            group.appendChild(bulb);

            // Mercury level (0-30¬∞C range for visualization)
            const tempRange = { min: 0, max: 30 };
            const percentage = Math.max(0, Math.min(1, (temp - tempRange.min) / (tempRange.max - tempRange.min)));
            const mercuryHeight = (tubeHeight - 10) * percentage + bulbRadius * 2 - 4;

            const mercuryColor = getTemperatureColor(temp);

            // Mercury in bulb
            const mercuryBulb = document.createElementNS(ns, 'circle');
            mercuryBulb.setAttribute('cx', tubeWidth / 2);
            mercuryBulb.setAttribute('cy', tubeHeight + bulbRadius - 4);
            mercuryBulb.setAttribute('r', bulbRadius - 4);
            mercuryBulb.setAttribute('fill', mercuryColor);
            mercuryBulb.setAttribute('class', 'mercury-fill');
            group.appendChild(mercuryBulb);

            // Mercury in tube
            const mercuryTube = document.createElementNS(ns, 'rect');
            mercuryTube.setAttribute('x', tubeWidth / 2 - 4);
            mercuryTube.setAttribute('y', tubeHeight - mercuryHeight + bulbRadius);
            mercuryTube.setAttribute('width', 8);
            mercuryTube.setAttribute('height', mercuryHeight - bulbRadius);
            mercuryTube.setAttribute('rx', 4);
            mercuryTube.setAttribute('fill', mercuryColor);
            mercuryTube.setAttribute('class', 'mercury-fill');
            group.appendChild(mercuryTube);

            // Scale markings
            for (let i = 0; i <= 4; i++) {
                const y = tubeHeight - (tubeHeight - 10) * (i / 4) + 5;
                const mark = document.createElementNS(ns, 'line');
                mark.setAttribute('x1', tubeWidth);
                mark.setAttribute('y1', y);
                mark.setAttribute('x2', tubeWidth + 5);
                mark.setAttribute('y2', y);
                mark.setAttribute('stroke', '#666');
                mark.setAttribute('stroke-width', '1');
                group.appendChild(mark);
            }

            // Temperature text
            const tempText = document.createElementNS(ns, 'text');
            tempText.setAttribute('x', tubeWidth / 2);
            tempText.setAttribute('y', tubeHeight + bulbRadius * 2 + 20);
            tempText.setAttribute('text-anchor', 'middle');
            tempText.setAttribute('font-size', '14');
            tempText.setAttribute('font-weight', '700');
            tempText.setAttribute('font-family', 'Baloo 2');
            tempText.setAttribute('fill', mercuryColor);
            tempText.setAttribute('id', elementId);
            tempText.textContent = temp.toFixed(1) + '¬∞C';
            group.appendChild(tempText);

            // Room label
            const label = document.createElementNS(ns, 'text');
            label.setAttribute('x', tubeWidth / 2);
            label.setAttribute('y', -8);
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('font-size', '11');
            label.setAttribute('font-weight', '600');
            label.setAttribute('font-family', 'Fredoka');
            label.setAttribute('fill', '#333');
            label.textContent = roomName;
            group.appendChild(label);

            // Position the thermometer
            if (position.isOutdoor) {
                group.setAttribute('transform', `translate(${position.x}, ${position.y})`);
                document.getElementById('outdoor-thermometer-container').appendChild(group);
            } else {
                group.setAttribute('transform', `translate(${position.x}, ${position.y})`);
                document.getElementById('thermometers-container').appendChild(group);
            }

            return tempText;
        }

        function createSparkles(element) {
            const rect = element.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const sparkleEmojis = ['‚ú®', '‚≠ê', 'üåü', 'üí´', '‚ú®', '‚≠ê'];
            const numSparkles = 8;

            for (let i = 0; i < numSparkles; i++) {
                const sparkle = document.createElement('div');
                sparkle.className = 'sparkle-star';
                sparkle.textContent = sparkleEmojis[Math.floor(Math.random() * sparkleEmojis.length)];

                const angle = (Math.PI * 2 * i) / numSparkles;
                const distance = 50 + Math.random() * 30;
                const tx = Math.cos(angle) * distance;
                const ty = Math.sin(angle) * distance;

                sparkle.style.left = centerX + 'px';
                sparkle.style.top = centerY + 'px';
                sparkle.style.setProperty('--tx', tx + 'px');
                sparkle.style.setProperty('--ty', ty + 'px');

                document.body.appendChild(sparkle);

                setTimeout(() => sparkle.remove(), 1000);
            }
        }

        function mapLightToRoom(lightName) {
            const nameLower = lightName.toLowerCase();

            if (nameLower.includes('outdoor') || nameLower.includes('outside') || nameLower.includes('garden')) return 'Outdoor';

            // Guest bedroom must be checked BEFORE main bedroom to avoid conflicts
            if (nameLower.includes('guest')) return 'Guest Bedroom';

            // Main bedroom - check for various naming patterns
            if (nameLower.includes('main bedroom') || nameLower.includes('mainbedroom') ||
                nameLower === 'bedroomlight' || nameLower === 'bedroom') return 'Main Bedroom';

            if (nameLower.includes('landing')) return 'Landing';
            if (nameLower.includes('office')) return 'Home Office';
            if (nameLower.includes('bathroom') || nameLower.includes('bath')) return 'Bathroom';
            if (nameLower.includes('lounge')) return 'Lounge';
            if (nameLower.includes('hall')) return 'Hall';
            if (nameLower.includes('extension')) return 'Extension';
            if (nameLower.includes('kitchen')) return 'Kitchen';

            return null;
        }

        function updateOutdoorLamppost(isOn) {
            const bulb = document.getElementById('lamp-bulb');
            const panel1 = document.getElementById('lamp-panel-1');
            const panel2 = document.getElementById('lamp-panel-2');
            const panelCenter = document.getElementById('lamp-panel-center');
            const lampHousing = document.getElementById('lamp-housing');

            if (!bulb) return;

            // Make lamppost clickable
            if (lampHousing) {
                lampHousing.style.cursor = 'pointer';
            }

            if (isOn) {
                // Light is ON - glow effect
                bulb.setAttribute('fill', '#FFD700');
                bulb.setAttribute('filter', 'url(#glow)');
                panel1.setAttribute('fill', '#FFF4CC');
                panel1.setAttribute('opacity', '0.9');
                panel2.setAttribute('fill', '#FFF4CC');
                panel2.setAttribute('opacity', '0.9');
                panelCenter.setAttribute('fill', '#FFEB99');
                panelCenter.setAttribute('opacity', '0.8');

                // Add light rays
                let rays = document.getElementById('lamp-rays');
                if (!rays) {
                    const ns = 'http://www.w3.org/2000/svg';
                    rays = document.createElementNS(ns, 'g');
                    rays.setAttribute('id', 'lamp-rays');
                    rays.setAttribute('opacity', '0.4');

                    // Create radiating light
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * 45) * Math.PI / 180;
                        const x1 = 155, y1 = 56;
                        const x2 = 155 + Math.cos(angle) * 30;
                        const y2 = 56 + Math.sin(angle) * 30;

                        const ray = document.createElementNS(ns, 'line');
                        ray.setAttribute('x1', x1);
                        ray.setAttribute('y1', y1);
                        ray.setAttribute('x2', x2);
                        ray.setAttribute('y2', y2);
                        ray.setAttribute('stroke', '#FFD700');
                        ray.setAttribute('stroke-width', '2');
                        ray.setAttribute('stroke-linecap', 'round');

                        rays.appendChild(ray);
                    }

                    document.getElementById('lamp-housing').appendChild(rays);
                }
                rays.style.display = 'block';
            } else {
                // Light is OFF - dark
                bulb.setAttribute('fill', '#666');
                bulb.removeAttribute('filter');
                panel1.setAttribute('fill', '#1a1a1a');
                panel1.setAttribute('opacity', '0.3');
                panel2.setAttribute('fill', '#1a1a1a');
                panel2.setAttribute('opacity', '0.3');
                panelCenter.setAttribute('fill', '#1a1a1a');
                panelCenter.setAttribute('opacity', '0.2');

                const rays = document.getElementById('lamp-rays');
                if (rays) rays.style.display = 'none';
            }
        }

        async function toggleLight(lightId, currentState) {
            try {
                const newState = !currentState;

                // Send command to Hue Bridge
                const response = await fetch(`http://${BRIDGE_IP}/api/${USERNAME}/lights/${lightId}/state`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ on: newState })
                });

                if (response.ok) {
                    console.log(`Light ${lightId} toggled to ${newState ? 'ON' : 'OFF'}`);
                    // Refresh lights after a short delay
                    setTimeout(loadLights, 500);
                } else {
                    console.error('Failed to toggle light');
                }
            } catch (error) {
                console.error('Error toggling light:', error);
            }
        }

        async function loadLights() {
            try {
                const response = await fetch(`http://${BRIDGE_IP}/api/${USERNAME}/lights`);
                if (!response.ok) return;

                const lights = await response.json();

                // Clear previous light data
                for (let room in roomLights) {
                    roomLights[room] = [];
                }

                // Map lights to rooms and detect changes
                for (const [lightId, lightInfo] of Object.entries(lights)) {
                    const room = mapLightToRoom(lightInfo.name);
                    if (room && roomLights[room]) {
                        const currentState = lightInfo.state.on;

                        // Check if this light's state changed
                        if (previousLightStates[lightId] !== undefined &&
                            previousLightStates[lightId] !== currentState &&
                            lightInfo.state.reachable) {
                            // Light state changed - announce it
                            announceLight(room, currentState);
                        }

                        // Update previous state
                        previousLightStates[lightId] = currentState;

                        roomLights[room].push({
                            id: lightId,
                            name: lightInfo.name,
                            on: currentState,
                            reachable: lightInfo.state.reachable
                        });
                    }
                }

                // Update light indicators in UI
                updateLightIndicators();

                // Update outdoor lamppost if there are outdoor lights
                if (roomLights['Outdoor'].length > 0) {
                    const outdoorLightOn = roomLights['Outdoor'].some(light => light.on);
                    updateOutdoorLamppost(outdoorLightOn);
                } else {
                    // If no outdoor light detected, turn it off
                    updateOutdoorLamppost(false);
                }

            } catch (error) {
                console.error('Error loading lights:', error);
            }
        }

        function mapMotionSensorToRoom(sensorName) {
            const nameLower = sensorName.toLowerCase();

            if (nameLower.includes('outdoor') || nameLower.includes('outside') || nameLower.includes('garden')) return 'Outdoor';
            if (nameLower.includes('hall') || nameLower.includes('frontdoor') || nameLower.includes('front door')) return 'Hall';
            if (nameLower.includes('landing')) return 'Landing';
            if (nameLower.includes('bathroom') || nameLower.includes('bath')) return 'Bathroom';

            return null;
        }

        async function loadSensorDetails() {
            try {
                const response = await fetch(`http://${BRIDGE_IP}/api/${USERNAME}/sensors`);
                if (!response.ok) return;

                const sensors = await response.json();
                const container = document.getElementById('sensor-details');
                if (!container) return;

                // Group sensors by their physical device (based on uniqueid prefix)
                const sensorGroups = {};

                for (const [sensorId, sensorInfo] of Object.entries(sensors)) {
                    // Extract base name (remove "motion sensor", "temperature", etc.)
                    let baseName = sensorInfo.name
                        .replace(/temperature sensor/i, '')
                        .replace(/motion sensor/i, '')
                        .replace(/ambient light sensor/i, '')
                        .replace(/\d+$/i, '') // Remove trailing numbers
                        .trim();

                    if (!baseName) baseName = sensorInfo.name;

                    if (!sensorGroups[baseName]) {
                        sensorGroups[baseName] = {
                            name: baseName,
                            temperature: null,
                            lightLevel: null,
                            motion: null,
                            battery: null
                        };
                    }

                    // Collect data based on sensor type
                    if (sensorInfo.type === 'ZLLTemperature' && sensorInfo.state.temperature !== null) {
                        sensorGroups[baseName].temperature = (sensorInfo.state.temperature / 100).toFixed(1);
                    }
                    if (sensorInfo.type === 'ZLLLightLevel' && sensorInfo.state.lightlevel !== null) {
                        sensorGroups[baseName].lightLevel = sensorInfo.state.lightlevel;
                        sensorGroups[baseName].lux = sensorInfo.state.daylight ? 'Daylight' : sensorInfo.state.dark ? 'Dark' : 'Dim';
                    }
                    if (sensorInfo.type === 'ZLLPresence') {
                        sensorGroups[baseName].motion = sensorInfo.state.presence;
                    }
                    if (sensorInfo.config && sensorInfo.config.battery !== undefined) {
                        sensorGroups[baseName].battery = sensorInfo.config.battery;
                    }
                }

                // Build HTML for sensor cards
                let html = '';
                for (const [key, sensor] of Object.entries(sensorGroups)) {
                    // Only show sensors that have at least one data point
                    if (!sensor.temperature && sensor.lightLevel === null && sensor.motion === null && sensor.battery === null) {
                        continue;
                    }

                    const roomEmoji = {
                        'Landing': 'ü™ú',
                        'Main Bedroom': 'üõèÔ∏è',
                        'Guest Room': 'üõèÔ∏è',
                        'Hue temperature sensor': 'üè¢',
                        'Bathroom': 'üöø',
                        'Hall': 'üö™',
                        'Lounge': 'üõãÔ∏è',
                        'ExtensionDimmer': 'üè†',
                        'KitchenSensor': 'üç≥',
                        'Hue outdoor temp. sensor': 'üå≥'
                    };
                    const emoji = roomEmoji[sensor.name] || 'üìç';

                    // Battery color based on level
                    let batteryColor = '#4CAF50'; // Green
                    if (sensor.battery !== null) {
                        if (sensor.battery < 20) batteryColor = '#f44336'; // Red
                        else if (sensor.battery < 50) batteryColor = '#FF9800'; // Orange
                    }

                    // Light level emoji
                    let lightEmoji = '‚òÄÔ∏è';
                    if (sensor.lux === 'Dark') lightEmoji = 'üåô';
                    else if (sensor.lux === 'Dim') lightEmoji = 'üå§Ô∏è';

                    html += `<div style="background: linear-gradient(135deg, #ffffff 0%, #f5f5f5 100%); padding: 15px; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); border: 2px solid #e0e0e0;">`;
                    html += `<div style="font-weight: 700; font-size: 16px; margin-bottom: 12px; color: #333; font-family: 'Fredoka', sans-serif;">${emoji} ${sensor.name}</div>`;

                    // Temperature
                    if (sensor.temperature) {
                        const tempColor = getTemperatureColor(parseFloat(sensor.temperature));
                        html += `<div style="display: flex; align-items: center; margin-bottom: 8px; padding: 6px; background: white; border-radius: 8px;">`;
                        html += `<span style="font-size: 20px; margin-right: 8px;">üå°Ô∏è</span>`;
                        html += `<span style="flex: 1; font-weight: 600;">Temperature</span>`;
                        html += `<span style="font-weight: 700; color: ${tempColor}; font-size: 18px;">${sensor.temperature}¬∞C</span>`;
                        html += `</div>`;
                    }

                    // Light Level
                    if (sensor.lightLevel !== null) {
                        html += `<div style="display: flex; align-items: center; margin-bottom: 8px; padding: 6px; background: white; border-radius: 8px;">`;
                        html += `<span style="font-size: 20px; margin-right: 8px;">${lightEmoji}</span>`;
                        html += `<span style="flex: 1; font-weight: 600;">Light Level</span>`;
                        html += `<span style="font-weight: 700; color: #FFA500;">${sensor.lux} (${sensor.lightLevel})</span>`;
                        html += `</div>`;
                    }

                    // Motion
                    if (sensor.motion !== null) {
                        const motionColor = sensor.motion ? '#f44336' : '#4CAF50';
                        const motionText = sensor.motion ? 'üö∂ DETECTED' : '‚úÖ Clear';
                        html += `<div style="display: flex; align-items: center; margin-bottom: 8px; padding: 6px; background: white; border-radius: 8px;">`;
                        html += `<span style="flex: 1; font-weight: 600;">Motion</span>`;
                        html += `<span style="font-weight: 700; color: ${motionColor};">${motionText}</span>`;
                        html += `</div>`;
                    }

                    // Battery
                    if (sensor.battery !== null) {
                        let batteryIcon = 'üîã';
                        if (sensor.battery < 20) batteryIcon = 'ü™´';
                        html += `<div style="display: flex; align-items: center; padding: 6px; background: white; border-radius: 8px;">`;
                        html += `<span style="font-size: 20px; margin-right: 8px;">${batteryIcon}</span>`;
                        html += `<span style="flex: 1; font-weight: 600;">Battery</span>`;
                        html += `<span style="font-weight: 700; color: ${batteryColor};">${sensor.battery}%</span>`;
                        html += `</div>`;
                    }

                    html += `</div>`;
                }

                container.innerHTML = html || '<div style="text-align: center; color: #999; padding: 20px;">No sensor data available</div>';

            } catch (error) {
                console.error('Error loading sensor details:', error);
            }
        }

        async function loadMotionSensors() {
            try {
                const response = await fetch(`http://${BRIDGE_IP}/api/${USERNAME}/sensors`);
                if (!response.ok) return;

                const sensors = await response.json();

                // Debug: log all motion sensors found
                console.log('=== Motion Sensors Scan ===');

                // Process motion sensors
                for (const [sensorId, sensorInfo] of Object.entries(sensors)) {
                    if (sensorInfo.type === 'ZLLPresence') {
                        const room = mapMotionSensorToRoom(sensorInfo.name);

                        // Debug logging
                        console.log(`Sensor: "${sensorInfo.name}" | Presence: ${sensorInfo.state.presence} | Mapped to: ${room || 'UNMAPPED'}`);

                        if (room && motionSensors[room]) {
                            // Store previous state
                            motionSensors[room].previousDetected = motionSensors[room].detected;

                            // Update current state
                            motionSensors[room].detected = sensorInfo.state.presence;
                            motionSensors[room].lastUpdated = sensorInfo.state.lastupdated;

                            // Check if motion just started (changed from false to true)
                            if (motionSensors[room].detected && !motionSensors[room].previousDetected) {
                                console.log(`üîä ANNOUNCING: Motion in ${room}`);
                                announceMotion(room);
                                logMotionEvent(room); // Log the event
                            }
                        }
                    }
                }

                // Update motion indicators in UI
                updateMotionIndicators();

            } catch (error) {
                console.error('Error loading motion sensors:', error);
            }
        }

        function updateMotionIndicators() {
            const positions = {
                'Outdoor': { x: 155, y: 100, isOutdoor: true },
                'Hall': { x: 200, y: 420 },
                'Landing': { x: 340, y: 250 },
                'Bathroom': { x: 660, y: 250 }
            };

            const container = document.getElementById('motion-indicators-container');
            if (!container) return;

            // Clear both indoor and outdoor motion indicators
            container.innerHTML = '';

            // Clear outdoor motion indicators (they're in the outdoor-area container)
            const outdoorArea = document.querySelector('#outdoor-area');
            if (outdoorArea) {
                // Remove any existing motion indicator groups from outdoor area
                const outdoorMotionIndicators = outdoorArea.querySelectorAll('.motion-indicator');
                outdoorMotionIndicators.forEach(el => el.remove());
            }

            const ns = 'http://www.w3.org/2000/svg';

            for (const [room, motion] of Object.entries(motionSensors)) {
                if (!motion.detected) continue; // Only show when motion detected

                const pos = positions[room];
                if (!pos) continue;

                // Create motion indicator group
                const group = document.createElementNS(ns, 'g');
                group.setAttribute('class', 'motion-indicator'); // Add class for easy cleanup

                if (pos.isOutdoor) {
                    // Position relative to outdoor area
                    group.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);
                } else {
                    group.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);
                }

                // Monkey face icon
                const monkeyGroup = document.createElementNS(ns, 'g');
                monkeyGroup.setAttribute('class', 'monkey-shake');

                // Monkey head (brown circle)
                const head = document.createElementNS(ns, 'circle');
                head.setAttribute('cx', '0');
                head.setAttribute('cy', '0');
                head.setAttribute('r', '18');
                head.setAttribute('fill', '#8B4513');
                head.setAttribute('stroke', '#5D2E0F');
                head.setAttribute('stroke-width', '2');
                monkeyGroup.appendChild(head);

                // Face area (lighter brown)
                const face = document.createElementNS(ns, 'ellipse');
                face.setAttribute('cx', '0');
                face.setAttribute('cy', '3');
                face.setAttribute('rx', '12');
                face.setAttribute('ry', '10');
                face.setAttribute('fill', '#D2691E');
                monkeyGroup.appendChild(face);

                // Left ear
                const leftEar = document.createElementNS(ns, 'circle');
                leftEar.setAttribute('cx', '-15');
                leftEar.setAttribute('cy', '-8');
                leftEar.setAttribute('r', '6');
                leftEar.setAttribute('fill', '#8B4513');
                leftEar.setAttribute('stroke', '#5D2E0F');
                leftEar.setAttribute('stroke-width', '1.5');
                monkeyGroup.appendChild(leftEar);

                // Right ear
                const rightEar = document.createElementNS(ns, 'circle');
                rightEar.setAttribute('cx', '15');
                rightEar.setAttribute('cy', '-8');
                rightEar.setAttribute('r', '6');
                rightEar.setAttribute('fill', '#8B4513');
                rightEar.setAttribute('stroke', '#5D2E0F');
                rightEar.setAttribute('stroke-width', '1.5');
                monkeyGroup.appendChild(rightEar);

                // Left eye
                const leftEye = document.createElementNS(ns, 'circle');
                leftEye.setAttribute('cx', '-6');
                leftEye.setAttribute('cy', '-2');
                leftEye.setAttribute('r', '3');
                leftEye.setAttribute('fill', 'white');
                monkeyGroup.appendChild(leftEye);

                const leftPupil = document.createElementNS(ns, 'circle');
                leftPupil.setAttribute('cx', '-5');
                leftPupil.setAttribute('cy', '-1');
                leftPupil.setAttribute('r', '2');
                leftPupil.setAttribute('fill', 'black');
                monkeyGroup.appendChild(leftPupil);

                // Right eye
                const rightEye = document.createElementNS(ns, 'circle');
                rightEye.setAttribute('cx', '6');
                rightEye.setAttribute('cy', '-2');
                rightEye.setAttribute('r', '3');
                rightEye.setAttribute('fill', 'white');
                monkeyGroup.appendChild(rightEye);

                const rightPupil = document.createElementNS(ns, 'circle');
                rightPupil.setAttribute('cx', '7');
                rightPupil.setAttribute('cy', '-1');
                rightPupil.setAttribute('r', '2');
                rightPupil.setAttribute('fill', 'black');
                monkeyGroup.appendChild(rightPupil);

                // Nose
                const nose = document.createElementNS(ns, 'ellipse');
                nose.setAttribute('cx', '0');
                nose.setAttribute('cy', '5');
                nose.setAttribute('rx', '3');
                nose.setAttribute('ry', '2');
                nose.setAttribute('fill', '#5D2E0F');
                monkeyGroup.appendChild(nose);

                // Mouth (smile)
                const mouth = document.createElementNS(ns, 'path');
                mouth.setAttribute('d', 'M -5 8 Q 0 12 5 8');
                mouth.setAttribute('stroke', '#5D2E0F');
                mouth.setAttribute('stroke-width', '1.5');
                mouth.setAttribute('fill', 'none');
                mouth.setAttribute('stroke-linecap', 'round');
                monkeyGroup.appendChild(mouth);

                group.appendChild(monkeyGroup);

                // Schedule fade-out after 30 seconds
                setTimeout(() => {
                    monkeyGroup.setAttribute('class', 'monkey-shake monkey-fadeout');
                    // Remove the element after fade completes
                    setTimeout(() => {
                        group.remove();
                    }, 2000);
                }, 30000);

                // Pulsing circle around person
                const pulseCircle = document.createElementNS(ns, 'circle');
                pulseCircle.setAttribute('cx', '0');
                pulseCircle.setAttribute('cy', '0');
                pulseCircle.setAttribute('r', '15');
                pulseCircle.setAttribute('fill', 'none');
                pulseCircle.setAttribute('stroke', '#FF6B6B');
                pulseCircle.setAttribute('stroke-width', '2');
                pulseCircle.setAttribute('opacity', '0.6');
                pulseCircle.setAttribute('class', 'motion-pulse');
                group.appendChild(pulseCircle);

                // Motion text label
                const label = document.createElementNS(ns, 'text');
                label.setAttribute('x', '0');
                label.setAttribute('y', '35');
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('font-size', '12');
                label.setAttribute('font-weight', '700');
                label.setAttribute('font-family', 'Fredoka');
                label.setAttribute('fill', '#5D2E0F');
                label.textContent = 'OOH OOH!';
                group.appendChild(label);

                if (pos.isOutdoor) {
                    document.querySelector('#outdoor-area').appendChild(group);
                } else {
                    container.appendChild(group);
                }
            }
        }

        function updateLightIndicators() {
            const roomPositionsForLights = {
                'Main Bedroom': { x: 180, y: 240 },
                'Landing': { x: 340, y: 240 },
                'Home Office': { x: 500, y: 240 },
                'Bathroom': { x: 660, y: 240 },
                'Guest Bedroom': { x: 820, y: 240 },
                'Hall': { x: 200, y: 405 },
                'Lounge': { x: 400, y: 405 },
                'Kitchen': { x: 600, y: 405 },
                'Extension': { x: 800, y: 405 }
            };

            const container = document.getElementById('light-indicators-container');
            if (!container) return;

            container.innerHTML = '';

            const ns = 'http://www.w3.org/2000/svg';

            for (const [room, lights] of Object.entries(roomLights)) {
                if (lights.length === 0) continue;

                const pos = roomPositionsForLights[room];
                if (!pos) continue;

                // Create a group for this room's lights
                const group = document.createElementNS(ns, 'g');

                lights.forEach((light, index) => {
                    const offsetX = (index - (lights.length - 1) / 2) * 20;

                    // Light bulb icon
                    const bulb = document.createElementNS(ns, 'circle');
                    bulb.setAttribute('cx', pos.x + offsetX);
                    bulb.setAttribute('cy', pos.y);
                    bulb.setAttribute('r', 6);
                    bulb.setAttribute('fill', light.on ? '#FFD700' : '#666');
                    bulb.setAttribute('stroke', light.on ? '#FFA500' : '#333');
                    bulb.setAttribute('stroke-width', '1.5');
                    bulb.setAttribute('class', 'light-indicator');
                    bulb.style.cursor = 'pointer';

                    if (light.on) {
                        bulb.setAttribute('filter', 'url(#glow)');
                    }

                    // Tooltip
                    const title = document.createElementNS(ns, 'title');
                    title.textContent = `${light.name}: ${light.on ? 'ON' : 'OFF'} (double-click to toggle)`;
                    bulb.appendChild(title);

                    // Double-click to toggle light
                    bulb.addEventListener('dblclick', () => {
                        toggleLight(light.id, light.on);
                    });

                    group.appendChild(bulb);
                });

                container.appendChild(group);
            }
        }

        async function loadTemperatures(showSparkles = true) {
            const btn = document.getElementById('refreshBtn');
            if (showSparkles) btn.classList.add('loading');

            try {
                const response = await fetch(`http://${BRIDGE_IP}/api/${USERNAME}/sensors`);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const sensors = await response.json();
                const temps = [];

                // Clear existing thermometers
                document.getElementById('thermometers-container').innerHTML = '';
                document.getElementById('outdoor-thermometer-container').innerHTML = '';

                for (const [sensorId, sensorInfo] of Object.entries(sensors)) {
                    if (sensorInfo.type === 'ZLLTemperature') {
                        const name = sensorInfo.name;
                        const elementId = sensorMapping[name];

                        if (elementId) {
                            const temp = sensorInfo.state.temperature;

                            if (temp !== null && temp !== undefined) {
                                const tempC = (temp / 100.0).toFixed(1);
                                const roomName = roomNames[name] || name;

                                // Create thermometer for this room
                                const tempElement = createThermometer(elementId, parseFloat(tempC), roomName);

                                // Save temperature data for graphing
                                saveTempData(name, tempC);

                                // Create sparkles on update!
                                if (tempElement && showSparkles) {
                                    setTimeout(() => createSparkles(tempElement), 100);
                                }

                                // Only add to stats if not outdoor
                                if (name !== 'Hue outdoor temp. sensor 1') {
                                    temps.push(parseFloat(tempC));
                                }
                            }
                            // If temp is null/undefined, we simply don't create a thermometer (nothing displayed)
                        }
                    }
                }

                // Calculate statistics
                if (temps.length > 0) {
                    const avg = (temps.reduce((a, b) => a + b, 0) / temps.length).toFixed(1);
                    const max = Math.max(...temps).toFixed(1);
                    const min = Math.min(...temps).toFixed(1);
                    const range = (max - min).toFixed(1);

                    const avgEl = document.getElementById('avg-temp');
                    const maxEl = document.getElementById('max-temp');
                    const minEl = document.getElementById('min-temp');
                    const rangeEl = document.getElementById('range-temp');

                    avgEl.textContent = avg + '¬∞C';
                    maxEl.textContent = max + '¬∞C';
                    minEl.textContent = min + '¬∞C';
                    rangeEl.textContent = range + '¬∞C';

                    // Add sparkles to stats cards
                    if (showSparkles) {
                        setTimeout(() => createSparkles(avgEl), 100);
                        setTimeout(() => createSparkles(maxEl), 200);
                        setTimeout(() => createSparkles(minEl), 300);
                        setTimeout(() => createSparkles(rangeEl), 400);
                    }
                }

                const now = new Date();
                document.getElementById('lastUpdate').textContent =
                    `Last updated: ${now.toLocaleString()} ‚ú®`;

                // Redraw graph with new data
                drawGraph();

            } catch (error) {
                console.error('Error loading temperatures:', error);
                document.getElementById('lastUpdate').textContent =
                    `‚ö†Ô∏è Oops! ${error.message}`;
            } finally {
                if (showSparkles) btn.classList.remove('loading');
            }
        }

        // Diagnostic: Show all lights
        async function showAllLights() {
            try {
                const response = await fetch(`http://${BRIDGE_IP}/api/${USERNAME}/lights`);
                const lights = await response.json();

                console.log('\n');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('                    ALL HUE LIGHTS                         ');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('\n');

                for (const [id, light] of Object.entries(lights)) {
                    const room = mapLightToRoom(light.name);
                    console.log(`‚îå‚îÄ Light ID: ${id} ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
                    console.log(`‚îÇ Name: "${light.name}"`);
                    console.log(`‚îÇ Type: ${light.type}`);
                    console.log(`‚îÇ Model: ${light.modelid || 'N/A'}`);
                    console.log(`‚îÇ State: ${light.state.on ? 'ON' : 'OFF'}`);
                    console.log(`‚îÇ Reachable: ${light.state.reachable}`);
                    console.log(`‚îÇ Mapped to room: ${room || '‚ùå NOT MAPPED'}`);
                    console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                    console.log('\n');
                }

                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log(`Total lights found: ${Object.keys(lights).length}`);
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('\n');

            } catch (error) {
                console.error('Error fetching lights:', error);
            }
        }

        // Diagnostic: Show all sensors
        async function showAllSensors() {
            try {
                const response = await fetch(`http://${BRIDGE_IP}/api/${USERNAME}/sensors`);
                const sensors = await response.json();

                console.log('\n');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('                    ALL HUE SENSORS                        ');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('\n');

                for (const [id, sensor] of Object.entries(sensors)) {
                    console.log(`‚îå‚îÄ Sensor ID: ${id} ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
                    console.log(`‚îÇ Name: "${sensor.name}"`);
                    console.log(`‚îÇ Type: ${sensor.type}`);
                    console.log(`‚îÇ Model: ${sensor.modelid || 'N/A'}`);
                    console.log(`‚îÇ Manufacturer: ${sensor.manufacturername || 'N/A'}`);

                    if (sensor.state) {
                        console.log(`‚îÇ State:`);
                        for (const [key, value] of Object.entries(sensor.state)) {
                            console.log(`‚îÇ   - ${key}: ${value}`);
                        }
                    }

                    console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                    console.log('\n');
                }

                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log(`Total sensors found: ${Object.keys(sensors).length}`);
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('\n');

            } catch (error) {
                console.error('Error fetching sensors:', error);
            }
        }

        // Initialize temperature history
        initTempHistory();

        // Initialize motion detection history
        initMotionHistory();

        // Toggle collapsible sections
        function toggleSection(contentId, arrowId) {
            const content = document.getElementById(contentId);
            const arrow = document.getElementById(arrowId);

            if (content && arrow) {
                content.classList.toggle('collapsed');
                arrow.classList.toggle('collapsed');
            }
        }

        // Chelmsford, Essex, UK coordinates
        const CHELMSFORD_LAT = 51.7356;
        const CHELMSFORD_LNG = 0.4685;

        // Store sunrise/sunset times
        let sunriseTime = null;
        let sunsetTime = null;

        // Fetch sunrise/sunset times for Chelmsford
        async function fetchSunTimes() {
            try {
                const response = await fetch(`https://api.sunrise-sunset.org/json?lat=${CHELMSFORD_LAT}&lng=${CHELMSFORD_LNG}&formatted=0`);
                const data = await response.json();

                if (data.status === 'OK') {
                    sunriseTime = new Date(data.results.sunrise);
                    sunsetTime = new Date(data.results.sunset);

                    console.log(`üåÖ Sunrise today: ${sunriseTime.toLocaleTimeString()}`);
                    console.log(`üåá Sunset today: ${sunsetTime.toLocaleTimeString()}`);

                    // Update sky immediately with new times
                    updateSky();
                }
            } catch (error) {
                console.error('Error fetching sun times:', error);
                // Fallback to default times if API fails
                const now = new Date();
                sunriseTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 7, 0);
                sunsetTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 17, 0);
            }
        }

        // Update sky based on time of day (using actual sunrise/sunset)
        function updateSky() {
            const now = new Date();

            const skyGradient = document.getElementById('skyGradient');
            const sun = document.getElementById('sun');
            const moon = document.getElementById('moon');
            const stars = document.getElementById('stars');

            if (!skyGradient) return;

            // If we don't have sun times yet, use defaults
            if (!sunriseTime || !sunsetTime) {
                sunriseTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 7, 0);
                sunsetTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 17, 0);
            }

            // Calculate time periods based on actual sunrise/sunset
            const dawnStart = new Date(sunriseTime.getTime() - 60 * 60 * 1000); // 1 hour before sunrise
            const dawnEnd = sunriseTime;
            const duskStart = sunsetTime;
            const duskEnd = new Date(sunsetTime.getTime() + 90 * 60 * 1000); // 1.5 hours after sunset

            let skyConfig;

            // Determine sky configuration based on actual sun times
            if (now >= dawnStart && now < dawnEnd) {
                // Dawn (1 hour before sunrise)
                skyConfig = {
                    color1: '#FF6B6B', // Pink
                    color2: '#FFD93D', // Golden yellow
                    showSun: true,
                    showMoon: false,
                    showStars: false
                };
            } else if (now >= dawnEnd && now < duskStart) {
                // Day (sunrise to sunset)
                skyConfig = {
                    color1: '#87CEEB', // Sky blue
                    color2: '#E0F6FF', // Very light blue
                    showSun: true,
                    showMoon: false,
                    showStars: false
                };
            } else if (now >= duskStart && now < duskEnd) {
                // Dusk (sunset to 1.5 hours after)
                skyConfig = {
                    color1: '#FF6B35', // Orange
                    color2: '#6A4C93', // Purple
                    showSun: true,
                    showMoon: false,
                    showStars: true
                };
            } else {
                // Night (rest of the time)
                skyConfig = {
                    color1: '#0B1026', // Dark blue/black
                    color2: '#1E3A5F', // Deep blue
                    showSun: false,
                    showMoon: true,
                    showStars: true
                };
            }

            // Update sky gradient
            const stops = skyGradient.getElementsByTagName('stop');
            if (stops.length >= 2) {
                stops[0].setAttribute('style', `stop-color:${skyConfig.color1};stop-opacity:1`);
                stops[1].setAttribute('style', `stop-color:${skyConfig.color2};stop-opacity:1`);
            }

            // Show/hide sun, moon, and stars
            if (sun) sun.style.display = skyConfig.showSun ? 'block' : 'none';
            if (moon) moon.style.display = skyConfig.showMoon ? 'block' : 'none';
            if (stars) stars.style.display = skyConfig.showStars ? 'block' : 'none';
        }

        // Setup outdoor lamppost double-click handler
        function setupLampostClickHandler() {
            const lampHousing = document.getElementById('lamp-housing');
            if (lampHousing) {
                lampHousing.addEventListener('dblclick', () => {
                    // Find the outdoor light
                    if (roomLights['Outdoor'] && roomLights['Outdoor'].length > 0) {
                        const outdoorLight = roomLights['Outdoor'][0];
                        toggleLight(outdoorLight.id, outdoorLight.on);
                    }
                });
            }
        }

        // Show all sensors and lights for debugging
        showAllSensors();
        showAllLights();

        // Fetch sunrise/sunset times for Chelmsford and update sky
        fetchSunTimes();

        // Load all data on page load
        loadTemperatures();
        loadLights().then(() => {
            // Setup lamppost click handler after lights are loaded
            setupLampostClickHandler();
        });
        loadMotionSensors();
        loadSensorDetails();

        // Real-time polling with different intervals for different data types
        // Motion sensors: every 3 seconds (critical for real-time detection)
        setInterval(loadMotionSensors, 3000);

        // Lights: every 10 seconds (change frequently)
        setInterval(loadLights, 10000);

        // Sensor details: every 10 seconds (includes light levels, battery, motion)
        setInterval(loadSensorDetails, 10000);

        // Temperatures: every 60 seconds (change slowly, without sparkles to reduce visual noise)
        setInterval(() => loadTemperatures(false), 60000);

        // Update motion log display every minute to refresh "time ago"
        setInterval(updateMotionLogDisplay, 60000);

        // Update sky every minute to check for time of day changes
        setInterval(updateSky, 60000);

        // Refresh sunrise/sunset times once per day (every 24 hours)
        setInterval(fetchSunTimes, 24 * 60 * 60 * 1000);

        // ============================================================================
        // FUN LIGHT EFFECTS
        // ============================================================================

        let originalLightStates = {};
        let effectInProgress = false;

        // Helper: Get all lights with their current state
        async function getAllLights() {
            try {
                const response = await fetch(`http://${BRIDGE_IP}/api/${USERNAME}/lights`);
                if (!response.ok) return null;
                return await response.json();
            } catch (error) {
                console.error('Error getting lights:', error);
                return null;
            }
        }

        // Helper: Set a light to specific state
        async function setLightState(lightId, state) {
            try {
                await fetch(`http://${BRIDGE_IP}/api/${USERNAME}/lights/${lightId}/state`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(state)
                });
            } catch (error) {
                console.error(`Error setting light ${lightId}:`, error);
            }
        }

        // Helper: Save current state of all lights
        async function saveLightStates() {
            const lights = await getAllLights();
            if (!lights) return false;

            originalLightStates = {};
            for (const [lightId, light] of Object.entries(lights)) {
                originalLightStates[lightId] = {
                    on: light.state.on,
                    bri: light.state.bri,
                    hue: light.state.hue,
                    sat: light.state.sat
                };
            }
            return true;
        }

        // Helper: Restore original light states
        async function restoreLightStates() {
            for (const [lightId, state] of Object.entries(originalLightStates)) {
                await setLightState(lightId, state);
                await new Promise(resolve => setTimeout(resolve, 50)); // Small delay between commands
            }
            setTimeout(loadLights, 500); // Refresh UI
            effectInProgress = false;
        }

        // Helper: Disable all effect buttons
        function disableEffectButtons(disable) {
            const buttons = ['redAlertBtn', 'partyBtn', 'discoBtn', 'waveBtn', 'sunsetBtn'];
            buttons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) btn.disabled = disable;
            });
        }

        // üö® RED ALERT - Flash all lights red
        async function redAlert() {
            if (effectInProgress) return;
            effectInProgress = true;
            disableEffectButtons(true);

            const success = await saveLightStates();
            if (!success) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            const lights = await getAllLights();
            if (!lights) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            // Flash red 6 times (3 seconds total)
            for (let i = 0; i < 6; i++) {
                // Turn all lights red and bright
                for (const lightId of Object.keys(lights)) {
                    await setLightState(lightId, {
                        on: true,
                        bri: 254,
                        hue: 0, // Red
                        sat: 254,
                        transitiontime: 0 // Instant
                    });
                }

                await new Promise(resolve => setTimeout(resolve, 250));

                // Turn all lights off briefly
                for (const lightId of Object.keys(lights)) {
                    await setLightState(lightId, { on: false, transitiontime: 0 });
                }

                await new Promise(resolve => setTimeout(resolve, 250));
            }

            // Restore original states
            await restoreLightStates();
            disableEffectButtons(false);
        }

        // üéâ PARTY MODE - Cycle through rainbow colors
        async function partyMode() {
            if (effectInProgress) return;
            effectInProgress = true;
            disableEffectButtons(true);

            const success = await saveLightStates();
            if (!success) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            const lights = await getAllLights();
            if (!lights) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            // Rainbow colors (hue values in Philips Hue scale: 0-65535)
            const colors = [
                0,      // Red
                10922,  // Orange
                12750,  // Yellow
                25500,  // Green
                46920,  // Blue
                56100   // Purple
            ];

            // Cycle through colors for 6 seconds
            for (let cycle = 0; cycle < 12; cycle++) {
                const hue = colors[cycle % colors.length];

                for (const lightId of Object.keys(lights)) {
                    await setLightState(lightId, {
                        on: true,
                        bri: 254,
                        hue: hue,
                        sat: 254,
                        transitiontime: 5 // Smooth transition
                    });
                }

                await new Promise(resolve => setTimeout(resolve, 500));
            }

            // Restore original states
            await restoreLightStates();
            disableEffectButtons(false);
        }

        // üï∫ DISCO - Random flashing colors
        async function discoMode() {
            if (effectInProgress) return;
            effectInProgress = true;
            disableEffectButtons(true);

            const success = await saveLightStates();
            if (!success) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            const lights = await getAllLights();
            if (!lights) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            const lightIds = Object.keys(lights);

            // Random flashing for 5 seconds
            for (let i = 0; i < 20; i++) {
                // Each light gets a random color
                for (const lightId of lightIds) {
                    const randomHue = Math.floor(Math.random() * 65535);
                    const randomOn = Math.random() > 0.3; // 70% chance to be on

                    await setLightState(lightId, {
                        on: randomOn,
                        bri: randomOn ? 254 : 0,
                        hue: randomHue,
                        sat: 254,
                        transitiontime: 0
                    });
                }

                await new Promise(resolve => setTimeout(resolve, 250));
            }

            // Restore original states
            await restoreLightStates();
            disableEffectButtons(false);
        }

        // üåä WAVE - Lights turn on in sequence
        async function waveEffect() {
            if (effectInProgress) return;
            effectInProgress = true;
            disableEffectButtons(true);

            const success = await saveLightStates();
            if (!success) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            const lights = await getAllLights();
            if (!lights) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            const lightIds = Object.keys(lights);

            // Turn all lights off first
            for (const lightId of lightIds) {
                await setLightState(lightId, { on: false, transitiontime: 0 });
            }

            await new Promise(resolve => setTimeout(resolve, 300));

            // Wave through lights 3 times
            for (let wave = 0; wave < 3; wave++) {
                for (const lightId of lightIds) {
                    // Turn this light on with cyan color
                    await setLightState(lightId, {
                        on: true,
                        bri: 254,
                        hue: 46920, // Cyan/Blue
                        sat: 254,
                        transitiontime: 0
                    });

                    await new Promise(resolve => setTimeout(resolve, 150));

                    // Turn it back off
                    await setLightState(lightId, { on: false, transitiontime: 2 });
                }
            }

            await new Promise(resolve => setTimeout(resolve, 500));

            // Restore original states
            await restoreLightStates();
            disableEffectButtons(false);
        }

        // üåÖ SUNSET - Gradual warm orange glow then fade
        async function sunsetMode() {
            if (effectInProgress) return;
            effectInProgress = true;
            disableEffectButtons(true);

            const success = await saveLightStates();
            if (!success) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            const lights = await getAllLights();
            if (!lights) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            // Fade to warm sunset orange
            for (const lightId of Object.keys(lights)) {
                await setLightState(lightId, {
                    on: true,
                    bri: 200,
                    hue: 5000, // Warm orange
                    sat: 200,
                    transitiontime: 30 // 3 seconds fade in
                });
            }

            await new Promise(resolve => setTimeout(resolve, 3500));

            // Hold for 2 seconds
            await new Promise(resolve => setTimeout(resolve, 2000));

            // Fade to dim
            for (const lightId of Object.keys(lights)) {
                await setLightState(lightId, {
                    on: true,
                    bri: 1,
                    transitiontime: 30 // 3 seconds fade out
                });
            }

            await new Promise(resolve => setTimeout(resolve, 3500));

            // Restore original states
            await restoreLightStates();
            disableEffectButtons(false);
        }
    </script>
</body>
</html>
