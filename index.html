<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
    <title>üè† 28 Barn Green - Home Monitor</title>

    <!-- PWA Meta Tags -->
    <meta name="description" content="Home monitoring dashboard for 28 Barn Green">
    <meta name="theme-color" content="#87CEEB">
    <link rel="manifest" href="/manifest.json">

    <!-- Apple Touch Icons -->
    <link rel="apple-touch-icon" href="/icons/icon-152x152.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Home Monitor">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&family=Baloo+2:wght@400;700&display=swap');

        :root {
            /* Light mode colors (default) */
            --bg-gradient: linear-gradient(180deg, #87CEEB 0%, #98D8E8 30%, #F0E68C 70%, #90EE90 100%);
            --bg-container: rgba(255, 255, 255, 0.95);
            --bg-card: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --bg-button: linear-gradient(135deg, #FF6B9D 0%, #FFA07A 100%);
            --bg-graph: rgba(255, 255, 255, 0.9);

            --text-primary: #333;
            --text-secondary: #666;
            --text-light: #999;
            --text-heading: linear-gradient(135deg, #FF6B9D 0%, #FFA07A 50%, #FFD700 100%);

            --shadow-primary: 0 10px 30px rgba(0, 0, 0, 0.2);
            --shadow-button: 0 10px 30px rgba(255, 107, 157, 0.4);
            --shadow-card: 0 10px 30px rgba(102, 126, 234, 0.3);

            --border-color: rgba(255, 255, 255, 0.3);

            /* SVG colors */
            --cloud-color: white;
            --cloud-opacity: 0.7;
            --bird-color: #333;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                /* Dark mode colors */
                --bg-gradient: linear-gradient(180deg, #0B1026 0%, #1A1A2E 30%, #16213E 70%, #0F3460 100%);
                --bg-container: rgba(20, 20, 30, 0.95);
                --bg-card: linear-gradient(135deg, #3A4A6B 0%, #2D3A5C 100%);
                --bg-button: linear-gradient(135deg, #C84B6D 0%, #9A5F7A 100%);
                --bg-graph: rgba(25, 25, 35, 0.9);

                --text-primary: #E0E0E0;
                --text-secondary: #A0A0A0;
                --text-light: #707070;
                --text-heading: linear-gradient(135deg, #FF8FB1 0%, #C89FAA 50%, #FFD700 100%);

                --shadow-primary: 0 10px 30px rgba(0, 0, 0, 0.6);
                --shadow-button: 0 10px 30px rgba(200, 75, 109, 0.4);
                --shadow-card: 0 10px 30px rgba(58, 74, 107, 0.5);

                --border-color: rgba(255, 255, 255, 0.1);

                /* SVG night theme colors */
                --cloud-color: #4A5568;
                --cloud-opacity: 0.4;
                --bird-color: #718096;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Fredoka', sans-serif;
            background: var(--bg-gradient);
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            position: relative;
            overflow: hidden;
        }

        /* Floating clouds */
        .cloud {
            position: absolute;
            background: var(--cloud-color);
            border-radius: 100px;
            opacity: var(--cloud-opacity);
            animation: float-cloud 30s infinite linear;
        }

        .cloud::before,
        .cloud::after {
            content: '';
            position: absolute;
            background: var(--cloud-color);
            border-radius: 100px;
        }

        .cloud1 {
            width: 100px;
            height: 40px;
            top: 10%;
            left: -150px;
        }

        .cloud1::before {
            width: 50px;
            height: 50px;
            top: -25px;
            left: 10px;
        }

        .cloud1::after {
            width: 60px;
            height: 40px;
            top: -15px;
            right: 10px;
        }

        .cloud2 {
            width: 120px;
            height: 50px;
            top: 20%;
            left: -200px;
            animation-delay: -15s;
        }

        .cloud2::before {
            width: 60px;
            height: 60px;
            top: -30px;
            left: 15px;
        }

        .cloud2::after {
            width: 70px;
            height: 50px;
            top: -20px;
            right: 15px;
        }

        @keyframes float-cloud {
            to {
                left: calc(100% + 200px);
            }
        }

        /* Birds */
        .bird {
            position: absolute;
            font-size: 24px;
            animation: fly 20s infinite ease-in-out;
            opacity: 0.6;
            color: var(--bird-color);
        }

        .bird1 {
            top: 15%;
            left: -50px;
        }

        .bird2 {
            top: 25%;
            left: -80px;
            animation-delay: -7s;
        }

        @keyframes fly {
            to {
                left: calc(100% + 100px);
                top: calc(15% + 50px);
            }
        }

        .container {
            background: var(--bg-container);
            backdrop-filter: blur(15px);
            border-radius: 30px;
            padding: 20px;
            box-shadow: var(--shadow-primary);
            max-width: 1400px;
            max-height: 95vh;
            width: 100%;
            position: relative;
            z-index: 1;
            border: 4px solid var(--border-color);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .container::-webkit-scrollbar {
            width: 10px;
        }

        .container::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 10px;
        }

        .container::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
        }

        .container::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #5568d3 0%, #653a8a 100%);
        }

        h1 {
            text-align: center;
            background: linear-gradient(135deg, #FF6B9D 0%, #FFA07A 50%, #FFD700 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
            font-size: 2em;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            animation: wiggle 3s ease-in-out infinite;
        }

        @keyframes wiggle {
            0%, 100% { transform: rotate(-1deg); }
            50% { transform: rotate(1deg); }
        }

        .last-update {
            text-align: center;
            color: #666;
            margin-bottom: 15px;
            font-size: 0.85em;
        }

        .house-container {
            position: relative;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        svg {
            width: 100%;
            height: auto;
            filter: drop-shadow(0 10px 30px rgba(0, 0, 0, 0.2));
        }

        .room-fill {
            transition: all 0.4s ease;
        }

        .room-fill:hover {
            filter: brightness(1.15);
            transform: scale(1.02);
        }

        .temp-badge, .thermometer {
            cursor: move;
            transition: opacity 0.2s ease;
        }

        .thermometer:hover {
            animation: thermometer-pulse 1.5s ease-in-out infinite;
        }

        @keyframes thermometer-pulse {
            0%, 100% { transform: scale(1) translateY(0); }
            50% { transform: scale(1.05) translateY(-2px); filter: brightness(1.1); }
        }

        /* Touch-friendly improvements */
        @media (hover: none) and (pointer: coarse) {
            /* Remove hover effects on touch devices */
            .thermometer:hover {
                animation: none;
            }

            .refresh-btn:hover {
                transform: none;
                box-shadow: 0 10px 30px rgba(255, 107, 157, 0.4);
            }

            .stat-card:hover {
                transform: none;
            }

            /* Increase tap targets */
            .refresh-btn {
                padding: 15px 35px;
                font-size: 16px;
            }

            .thermometer {
                cursor: grab;
            }

            .thermometer:active {
                cursor: grabbing;
            }
        }

        /* Prevent text selection during drag */
        .thermometer {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        .temp-display {
            font-family: 'Baloo 2', cursive;
            font-size: 28px;
            font-weight: 700;
            animation: bounce 2s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .stat-card {
            background: var(--bg-card);
            padding: 15px;
            border-radius: 20px;
            color: white;
            text-align: center;
            box-shadow: var(--shadow-card);
            transition: all 0.3s ease;
            border: 3px solid var(--border-color);
        }

        .stat-card:hover {
            transform: translateY(-8px) rotate(2deg);
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.5);
        }

        .stat-label {
            font-size: 0.75em;
            opacity: 0.95;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: 700;
            font-family: 'Baloo 2', cursive;
        }

        /* Weather widget styles */
        .weather-card {
            grid-column: span 2;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .weather-main {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
        }

        .weather-icon {
            width: 50px;
            height: 50px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
        }

        .weather-temp-container {
            text-align: left;
        }

        .weather-condition {
            font-size: 0.8em;
            opacity: 0.9;
            margin-top: -5px;
        }

        .weather-details {
            font-size: 0.85em;
            opacity: 0.95;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .weather-extra {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        @media (max-width: 768px) {
            .weather-card {
                grid-column: span 1;
            }
        }

        .refresh-btn {
            display: block;
            margin: 15px auto 0;
            padding: 10px 30px;
            background: var(--bg-button);
            color: white;
            border: none;
            border-radius: 50px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-button);
            font-family: 'Fredoka', sans-serif;
            border: 3px solid var(--border-color);
        }

        .refresh-btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 40px rgba(255, 107, 157, 0.6);
        }

        .refresh-btn:active {
            transform: translateY(-2px) scale(1.02);
        }

        .refresh-btn.loading {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            100% { transform: rotate(360deg); }
        }

        /* Sparkle animation */
        .sparkle {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
        }

        .sparkle-star {
            position: absolute;
            font-size: 20px;
            animation: sparkle-float 1s ease-out forwards;
        }

        @keyframes sparkle-float {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(0) rotate(0deg);
            }
            50% {
                opacity: 1;
                transform: translate(var(--tx), var(--ty)) scale(1.5) rotate(180deg);
            }
            100% {
                opacity: 0;
                transform: translate(calc(var(--tx) * 2), calc(var(--ty) * 2)) scale(0) rotate(360deg);
            }
        }

        @keyframes sparkle {
            0%, 100% { opacity: 0; transform: scale(0); }
            50% { opacity: 1; transform: scale(1); }
        }

        /* Glow effect for updated temps */
        .temp-updated {
            animation: temp-glow 1s ease-out;
        }

        @keyframes temp-glow {
            0%, 100% { filter: drop-shadow(0 0 0 transparent); }
            50% { filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.8)); }
        }

        /* Graph styles */
        .graph-container {
            margin-top: 20px;
            background: var(--bg-graph);
            border-radius: 20px;
            padding: 20px;
            box-shadow: var(--shadow-primary);
            border: 3px solid var(--border-color);
        }

        .graph-title {
            text-align: center;
            background: var(--text-heading);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
            font-size: 1.5em;
            font-weight: 700;
        }

        #temp-graph {
            width: 100%;
            height: auto;
            filter: drop-shadow(0 5px 15px rgba(0, 0, 0, 0.1));
        }

        .graph-line {
            fill: none;
            stroke-width: 3;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .graph-point {
            transition: all 0.3s ease;
        }

        .graph-point:hover {
            r: 8;
            filter: drop-shadow(0 0 10px currentColor);
        }

        @keyframes draw-line {
            to {
                stroke-dashoffset: 0;
            }
        }

        /* Motion detection animations */
        .motion-pulse {
            animation: motion-pulse 1.5s ease-out infinite;
        }

        @keyframes motion-pulse {
            0% {
                r: 15;
                opacity: 0.6;
            }
            50% {
                r: 25;
                opacity: 0.3;
            }
            100% {
                r: 15;
                opacity: 0.6;
            }
        }

        .motion-person {
            animation: motion-bounce 0.6s ease-in-out infinite alternate;
        }

        /* Monkey shake animation */
        .monkey-shake {
            animation: monkey-shake 2s ease-in-out infinite;
            transform-origin: center;
        }

        @keyframes monkey-shake {
            0%, 100% { transform: rotate(-3deg) translateX(-1px); }
            25% { transform: rotate(3deg) translateX(1px); }
            50% { transform: rotate(-3deg) translateX(-1px); }
            75% { transform: rotate(2deg) translateX(0.5px); }
        }

        /* Fade out animation */
        .monkey-fadeout {
            animation: fadeout 2s ease-out forwards;
        }

        @keyframes fadeout {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes motion-bounce {
            0% {
                transform: translateY(0);
            }
            100% {
                transform: translateY(-3px);
            }
        }

        /* Collapsible sections */
        .section-header {
            cursor: pointer;
            user-select: none;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .section-header:hover {
            transform: scale(1.02);
            filter: brightness(1.1);
        }

        .section-arrow {
            transition: transform 0.3s ease;
            font-size: 0.8em;
        }

        .section-arrow.collapsed {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.5s ease, opacity 0.3s ease, margin 0.3s ease;
            opacity: 1;
        }

        .collapsible-content.collapsed {
            max-height: 0;
            opacity: 0;
            margin: 0 !important;
        }

        /* ======================================================================
           PIXEL ART MOOSE ANIMATIONS
           ====================================================================== */

        @keyframes moose-walk-in {
            0% {
                transform: translateX(-150px);
                opacity: 0;
            }
            20% { opacity: 1; }
            100% {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes moose-walk-out {
            0% {
                transform: translateX(0);
                opacity: 1;
            }
            80% { opacity: 1; }
            100% {
                transform: translateX(150px);
                opacity: 0;
            }
        }

        @keyframes moose-bob {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }

        @keyframes window-clean {
            0%, 100% { transform: translateX(0) rotate(-10deg); }
            50% { transform: translateX(8px) rotate(10deg); }
        }

        @keyframes water-pour {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(-30deg); }
        }

        @keyframes mow-forward {
            0% { transform: translateX(0); }
            100% { transform: translateX(80px); }
        }

        @keyframes read-newspaper {
            0%, 100% { transform: rotate(-5deg); }
            50% { transform: rotate(5deg); }
        }

        @keyframes paint-brush {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-8px) rotate(-15deg); }
        }

        @keyframes telescope-pan {
            0% { transform: rotate(-15deg); }
            100% { transform: rotate(15deg); }
        }

        @keyframes water-droplet {
            0% {
                transform: translateY(0);
                opacity: 1;
            }
            100% {
                transform: translateY(20px);
                opacity: 0;
            }
        }

        @keyframes grass-pulse {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2) saturate(1.3); }
        }

        @keyframes window-brighten {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        @keyframes flower-bounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes speech-bubble-appear {
            0% {
                opacity: 0;
                transform: scale(0.8) translateY(10px);
            }
            10% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
            85% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
            100% {
                opacity: 0;
                transform: scale(0.9) translateY(-5px);
            }
        }
    </style>
</head>
<body>
    <!-- Clouds -->
    <div class="cloud cloud1"></div>
    <div class="cloud cloud2"></div>

    <!-- Birds -->
    <div class="bird bird1">üê¶</div>
    <div class="bird bird2">üïäÔ∏è</div>

    <div class="container">
        <h1>üè° 28 Barn Green üå°Ô∏è</h1>
        <div class="last-update" id="lastUpdate">Loading magical temperatures...</div>

        <div class="house-container">
            <svg viewBox="0 0 1000 650" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <!-- Gradients -->
                    <linearGradient id="skyGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" style="stop-color:#87CEEB;stop-opacity:0.3" />
                        <stop offset="100%" style="stop-color:#E0F6FF;stop-opacity:0.1" />
                    </linearGradient>

                    <linearGradient id="roofGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#FF6B6B;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#C92A2A;stop-opacity:1" />
                    </linearGradient>

                    <linearGradient id="wallGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#FFE66D;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#FFC93C;stop-opacity:1" />
                    </linearGradient>

                    <linearGradient id="grassGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" style="stop-color:#7AE582;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#4CAF50;stop-opacity:1" />
                    </linearGradient>

                    <!-- Nest Thermostat metallic gradient (Polished Silver) -->
                    <radialGradient id="nestMetalGradient" cx="30%" cy="30%">
                        <stop offset="0%" style="stop-color:#F5F5F5;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#D3D3D3;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#A8A8A8;stop-opacity:1" />
                    </radialGradient>

                    <!-- Room gradients - temperature based -->
                    <linearGradient id="coldGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#A8DADC;stop-opacity:0.9" />
                        <stop offset="100%" style="stop-color:#1D3557;stop-opacity:0.9" />
                    </linearGradient>

                    <linearGradient id="coolGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#B8F2E6;stop-opacity:0.9" />
                        <stop offset="100%" style="stop-color:#5FA9A1;stop-opacity:0.9" />
                    </linearGradient>

                    <linearGradient id="warmGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#FFD6A5;stop-opacity:0.9" />
                        <stop offset="100%" style="stop-color:#FFADAD;stop-opacity:0.9" />
                    </linearGradient>

                    <linearGradient id="hotGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#FF9999;stop-opacity:0.9" />
                        <stop offset="100%" style="stop-color:#FF6B6B;stop-opacity:0.9" />
                    </linearGradient>

                    <!-- Patterns -->
                    <pattern id="brickPattern" x="0" y="0" width="40" height="20" patternUnits="userSpaceOnUse">
                        <rect width="40" height="20" fill="none"/>
                        <rect width="18" height="8" x="1" y="1" fill="rgba(200,100,100,0.3)" stroke="rgba(150,50,50,0.4)" stroke-width="0.5"/>
                        <rect width="18" height="8" x="21" y="11" fill="rgba(200,100,100,0.3)" stroke="rgba(150,50,50,0.4)" stroke-width="0.5"/>
                    </pattern>

                    <filter id="shadow">
                        <feDropShadow dx="0" dy="6" stdDeviation="8" flood-opacity="0.4"/>
                    </filter>

                    <filter id="glow">
                        <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                        <feMerge>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                </defs>

                <!-- Sky background -->
                <rect width="1000" height="600" fill="url(#skyGradient)"/>

                <!-- Sun -->
                <g id="sun" style="animation: spin 30s linear infinite; transform-origin: 880px 100px;">
                    <circle cx="880" cy="100" r="50" fill="#FFD700" opacity="0.8" filter="url(#glow)"/>
                    <circle cx="880" cy="100" r="40" fill="#FFA500"/>
                </g>

                <!-- Moon (hidden during day) -->
                <g id="moon" style="display: none;">
                    <circle cx="850" cy="120" r="45" fill="#F0F0F0" filter="url(#glow)"/>
                    <circle cx="860" cy="115" r="40" fill="#E8E8E8"/>
                    <!-- Craters -->
                    <circle cx="845" cy="110" r="8" fill="#D0D0D0" opacity="0.6"/>
                    <circle cx="870" cy="125" r="6" fill="#D0D0D0" opacity="0.5"/>
                    <circle cx="855" cy="135" r="5" fill="#D0D0D0" opacity="0.7"/>
                </g>

                <!-- Stars (hidden during day) -->
                <g id="stars" style="display: none;">
                    <circle cx="100" cy="50" r="2" fill="white" opacity="0.9">
                        <animate attributeName="opacity" values="0.9;0.3;0.9" dur="3s" repeatCount="indefinite"/>
                    </circle>
                    <circle cx="200" cy="80" r="1.5" fill="white" opacity="0.8">
                        <animate attributeName="opacity" values="0.8;0.4;0.8" dur="2.5s" repeatCount="indefinite" begin="0.5s"/>
                    </circle>
                    <circle cx="350" cy="40" r="2" fill="white" opacity="0.9">
                        <animate attributeName="opacity" values="0.9;0.2;0.9" dur="4s" repeatCount="indefinite" begin="1s"/>
                    </circle>
                    <circle cx="500" cy="70" r="1.5" fill="white" opacity="0.7">
                        <animate attributeName="opacity" values="0.7;0.3;0.7" dur="3.5s" repeatCount="indefinite" begin="1.5s"/>
                    </circle>
                    <circle cx="650" cy="45" r="2" fill="white" opacity="0.9">
                        <animate attributeName="opacity" values="0.9;0.4;0.9" dur="3s" repeatCount="indefinite" begin="0.8s"/>
                    </circle>
                    <circle cx="750" cy="90" r="1.5" fill="white" opacity="0.8">
                        <animate attributeName="opacity" values="0.8;0.3;0.8" dur="2.8s" repeatCount="indefinite" begin="2s"/>
                    </circle>
                    <circle cx="150" cy="120" r="1" fill="white" opacity="0.7">
                        <animate attributeName="opacity" values="0.7;0.2;0.7" dur="3.2s" repeatCount="indefinite" begin="0.3s"/>
                    </circle>
                    <circle cx="300" cy="110" r="1.5" fill="white" opacity="0.8">
                        <animate attributeName="opacity" values="0.8;0.4;0.8" dur="3.8s" repeatCount="indefinite" begin="1.2s"/>
                    </circle>
                    <circle cx="450" cy="130" r="1" fill="white" opacity="0.7">
                        <animate attributeName="opacity" values="0.7;0.3;0.7" dur="2.7s" repeatCount="indefinite" begin="1.8s"/>
                    </circle>
                    <circle cx="600" cy="100" r="1.5" fill="white" opacity="0.9">
                        <animate attributeName="opacity" values="0.9;0.3;0.9" dur="3.3s" repeatCount="indefinite" begin="0.6s"/>
                    </circle>
                    <circle cx="800" cy="55" r="2" fill="white" opacity="0.8">
                        <animate attributeName="opacity" values="0.8;0.2;0.8" dur="4.2s" repeatCount="indefinite" begin="2.5s"/>
                    </circle>
                    <circle cx="920" cy="75" r="1.5" fill="white" opacity="0.9">
                        <animate attributeName="opacity" values="0.9;0.4;0.9" dur="3.6s" repeatCount="indefinite" begin="1.3s"/>
                    </circle>
                </g>

                <!-- Weather Effects -->
                <!-- Rain (hidden by default) -->
                <g id="rain" style="display: none;">
                    <line x1="50" y1="0" x2="48" y2="80" stroke="#A0C8E0" stroke-width="2" opacity="0.6">
                        <animate attributeName="y1" values="0;600" dur="1s" repeatCount="indefinite"/>
                        <animate attributeName="y2" values="80;680" dur="1s" repeatCount="indefinite"/>
                    </line>
                    <line x1="150" y1="0" x2="148" y2="80" stroke="#A0C8E0" stroke-width="2" opacity="0.6">
                        <animate attributeName="y1" values="-50;550" dur="1s" repeatCount="indefinite"/>
                        <animate attributeName="y2" values="30;630" dur="1s" repeatCount="indefinite"/>
                    </line>
                    <line x1="250" y1="0" x2="248" y2="80" stroke="#A0C8E0" stroke-width="2" opacity="0.6">
                        <animate attributeName="y1" values="0;600" dur="0.9s" repeatCount="indefinite"/>
                        <animate attributeName="y2" values="80;680" dur="0.9s" repeatCount="indefinite"/>
                    </line>
                    <line x1="350" y1="0" x2="348" y2="80" stroke="#A0C8E0" stroke-width="2" opacity="0.6">
                        <animate attributeName="y1" values="-30;570" dur="1.1s" repeatCount="indefinite"/>
                        <animate attributeName="y2" values="50;650" dur="1.1s" repeatCount="indefinite"/>
                    </line>
                    <line x1="450" y1="0" x2="448" y2="80" stroke="#A0C8E0" stroke-width="2" opacity="0.6">
                        <animate attributeName="y1" values="0;600" dur="1s" repeatCount="indefinite"/>
                        <animate attributeName="y2" values="80;680" dur="1s" repeatCount="indefinite"/>
                    </line>
                    <line x1="550" y1="0" x2="548" y2="80" stroke="#A0C8E0" stroke-width="2" opacity="0.6">
                        <animate attributeName="y1" values="-40;560" dur="0.95s" repeatCount="indefinite"/>
                        <animate attributeName="y2" values="40;640" dur="0.95s" repeatCount="indefinite"/>
                    </line>
                    <line x1="650" y1="0" x2="648" y2="80" stroke="#A0C8E0" stroke-width="2" opacity="0.6">
                        <animate attributeName="y1" values="0;600" dur="1.05s" repeatCount="indefinite"/>
                        <animate attributeName="y2" values="80;680" dur="1.05s" repeatCount="indefinite"/>
                    </line>
                    <line x1="750" y1="0" x2="748" y2="80" stroke="#A0C8E0" stroke-width="2" opacity="0.6">
                        <animate attributeName="y1" values="-20;580" dur="1s" repeatCount="indefinite"/>
                        <animate attributeName="y2" values="60;660" dur="1s" repeatCount="indefinite"/>
                    </line>
                    <line x1="850" y1="0" x2="848" y2="80" stroke="#A0C8E0" stroke-width="2" opacity="0.6">
                        <animate attributeName="y1" values="0;600" dur="0.92s" repeatCount="indefinite"/>
                        <animate attributeName="y2" values="80;680" dur="0.92s" repeatCount="indefinite"/>
                    </line>
                    <line x1="950" y1="0" x2="948" y2="80" stroke="#A0C8E0" stroke-width="2" opacity="0.6">
                        <animate attributeName="y1" values="-35;565" dur="1.08s" repeatCount="indefinite"/>
                        <animate attributeName="y2" values="45;645" dur="1.08s" repeatCount="indefinite"/>
                    </line>
                </g>

                <!-- Snow (hidden by default) -->
                <g id="snow" style="display: none;">
                    <circle cx="80" cy="0" r="3" fill="white" opacity="0.9">
                        <animate attributeName="cy" values="0;650" dur="8s" repeatCount="indefinite"/>
                        <animate attributeName="cx" values="80;90;75;85;80" dur="8s" repeatCount="indefinite"/>
                    </circle>
                    <circle cx="200" cy="0" r="4" fill="white" opacity="0.85">
                        <animate attributeName="cy" values="-50;600" dur="10s" repeatCount="indefinite"/>
                        <animate attributeName="cx" values="200;210;195;205;200" dur="10s" repeatCount="indefinite"/>
                    </circle>
                    <circle cx="320" cy="0" r="3.5" fill="white" opacity="0.9">
                        <animate attributeName="cy" values="0;650" dur="9s" repeatCount="indefinite"/>
                        <animate attributeName="cx" values="320;330;315;325;320" dur="9s" repeatCount="indefinite"/>
                    </circle>
                    <circle cx="450" cy="0" r="3" fill="white" opacity="0.88">
                        <animate attributeName="cy" values="-80;570" dur="11s" repeatCount="indefinite"/>
                        <animate attributeName="cx" values="450;460;445;455;450" dur="11s" repeatCount="indefinite"/>
                    </circle>
                    <circle cx="570" cy="0" r="4" fill="white" opacity="0.9">
                        <animate attributeName="cy" values="0;650" dur="8.5s" repeatCount="indefinite"/>
                        <animate attributeName="cx" values="570;580;565;575;570" dur="8.5s" repeatCount="indefinite"/>
                    </circle>
                    <circle cx="690" cy="0" r="3.5" fill="white" opacity="0.87">
                        <animate attributeName="cy" values="-100;550" dur="10.5s" repeatCount="indefinite"/>
                        <animate attributeName="cx" values="690;700;685;695;690" dur="10.5s" repeatCount="indefinite"/>
                    </circle>
                    <circle cx="810" cy="0" r="3" fill="white" opacity="0.9">
                        <animate attributeName="cy" values="0;650" dur="9.5s" repeatCount="indefinite"/>
                        <animate attributeName="cx" values="810;820;805;815;810" dur="9.5s" repeatCount="indefinite"/>
                    </circle>
                    <circle cx="920" cy="0" r="4" fill="white" opacity="0.86">
                        <animate attributeName="cy" values="-60;590" dur="11.5s" repeatCount="indefinite"/>
                        <animate attributeName="cx" values="920;930;915;925;920" dur="11.5s" repeatCount="indefinite"/>
                    </circle>
                </g>

                <!-- Fog/Mist (hidden by default) -->
                <g id="fog" style="display: none;">
                    <ellipse cx="200" cy="500" rx="300" ry="80" fill="white" opacity="0.3">
                        <animate attributeName="opacity" values="0.3;0.5;0.3" dur="6s" repeatCount="indefinite"/>
                    </ellipse>
                    <ellipse cx="600" cy="480" rx="350" ry="90" fill="white" opacity="0.25">
                        <animate attributeName="opacity" values="0.25;0.45;0.25" dur="7s" repeatCount="indefinite" begin="1s"/>
                    </ellipse>
                    <ellipse cx="400" cy="520" rx="280" ry="70" fill="white" opacity="0.35">
                        <animate attributeName="opacity" values="0.35;0.55;0.35" dur="5.5s" repeatCount="indefinite" begin="2s"/>
                    </ellipse>
                    <ellipse cx="800" cy="510" rx="320" ry="85" fill="white" opacity="0.28">
                        <animate attributeName="opacity" values="0.28;0.48;0.28" dur="6.5s" repeatCount="indefinite" begin="0.5s"/>
                    </ellipse>
                </g>

                <!-- Grass -->
                <ellipse cx="500" cy="620" rx="600" ry="80" fill="url(#grassGradient)"/>
                <ellipse cx="300" cy="595" rx="200" ry="35" fill="#69B578" opacity="0.6"/>
                <ellipse cx="700" cy="605" rx="250" ry="40" fill="#69B578" opacity="0.6"/>

                <!-- Pixel Art UK Semi-Detached House -->
                <g>
                    <!-- Attached neighbor house (left side, partial) -->
                    <rect x="20" y="250" width="80" height="350" fill="#8B4513" stroke="#654321" stroke-width="2"/>
                    <rect x="20" y="250" width="80" height="350" fill="url(#brickPattern)" opacity="0.8"/>

                    <!-- Main house structure - brick exterior -->
                    <rect x="100" y="200" width="800" height="400" fill="#A0522D" stroke="#654321" stroke-width="4"/>

                    <!-- Pixel brick pattern overlay -->
                    <defs>
                        <pattern id="pixelBrick" x="0" y="0" width="32" height="16" patternUnits="userSpaceOnUse">
                            <rect width="32" height="16" fill="#A0522D"/>
                            <rect x="0" y="0" width="15" height="7" fill="#8B4513" stroke="#654321" stroke-width="0.5"/>
                            <rect x="16" y="0" width="15" height="7" fill="#8B4513" stroke="#654321" stroke-width="0.5"/>
                            <rect x="8" y="8" width="15" height="7" fill="#8B4513" stroke="#654321" stroke-width="0.5"/>
                            <rect x="24" y="8" width="7" height="7" fill="#8B4513" stroke="#654321" stroke-width="0.5"/>
                            <rect x="0" y="8" width="7" height="7" fill="#8B4513" stroke="#654321" stroke-width="0.5"/>
                        </pattern>
                    </defs>
                    <rect x="100" y="200" width="800" height="400" fill="url(#pixelBrick)" opacity="0.6"/>

                    <!-- Pitched roof - pixel style -->
                    <polygon points="80,200 500,80 920,200" fill="#7D0000" stroke="#4A0000" stroke-width="3"/>
                    <!-- Roof tiles effect -->
                    <line x1="500" y1="80" x2="80" y2="200" stroke="#5A0000" stroke-width="2"/>
                    <line x1="500" y1="80" x2="920" y2="200" stroke="#5A0000" stroke-width="2"/>
                    <line x1="290" y1="140" x2="80" y2="200" stroke="#5A0000" stroke-width="1"/>
                    <line x1="710" y1="140" x2="920" y2="200" stroke="#5A0000" stroke-width="1"/>

                    <!-- Chimney stack - pixel style -->
                    <rect x="700" y="100" width="48" height="100" fill="#8B4513" stroke="#654321" stroke-width="2"/>
                    <rect x="700" y="100" width="48" height="100" fill="url(#pixelBrick)" opacity="0.7"/>
                    <rect x="692" y="92" width="64" height="16" fill="#654321"/>

                    <!-- Chimney pots -->
                    <rect x="708" y="76" width="12" height="20" fill="#654321" stroke="#000" stroke-width="1"/>
                    <rect x="728" y="76" width="12" height="20" fill="#654321" stroke="#000" stroke-width="1"/>

                    <!-- Smoke (pixelated) -->
                    <rect x="710" y="60" width="8" height="8" fill="#D3D3D3" opacity="0.5">
                        <animate attributeName="opacity" values="0.5;0.2;0.5" dur="2s" repeatCount="indefinite"/>
                    </rect>
                    <rect x="718" y="52" width="8" height="8" fill="#D3D3D3" opacity="0.4">
                        <animate attributeName="opacity" values="0.4;0.1;0.4" dur="2s" repeatCount="indefinite" begin="0.5s"/>
                    </rect>
                    <rect x="730" y="62" width="8" height="8" fill="#D3D3D3" opacity="0.5">
                        <animate attributeName="opacity" values="0.5;0.2;0.5" dur="2s" repeatCount="indefinite" begin="1s"/>
                    </rect>

                    <!-- Pixel art windows on exterior (first floor) -->
                    <g id="exterior-windows-first">
                        <rect x="140" y="240" width="48" height="56" fill="#87CEEB" stroke="#2C1507" stroke-width="2"/>
                        <line x1="164" y1="240" x2="164" y2="296" stroke="#2C1507" stroke-width="2"/>
                        <line x1="140" y1="268" x2="188" y2="268" stroke="#2C1507" stroke-width="2"/>

                        <rect x="300" y="240" width="48" height="56" fill="#87CEEB" stroke="#2C1507" stroke-width="2"/>
                        <line x1="324" y1="240" x2="324" y2="296" stroke="#2C1507" stroke-width="2"/>
                        <line x1="300" y1="268" x2="348" y2="268" stroke="#2C1507" stroke-width="2"/>

                        <rect x="460" y="240" width="48" height="56" fill="#87CEEB" stroke="#2C1507" stroke-width="2"/>
                        <line x1="484" y1="240" x2="484" y2="296" stroke="#2C1507" stroke-width="2"/>
                        <line x1="460" y1="268" x2="508" y2="268" stroke="#2C1507" stroke-width="2"/>

                        <rect x="620" y="240" width="48" height="56" fill="#87CEEB" stroke="#2C1507" stroke-width="2"/>
                        <line x1="644" y1="240" x2="644" y2="296" stroke="#2C1507" stroke-width="2"/>
                        <line x1="620" y1="268" x2="668" y2="268" stroke="#2C1507" stroke-width="2"/>

                        <rect x="780" y="240" width="48" height="56" fill="#87CEEB" stroke="#2C1507" stroke-width="2"/>
                        <line x1="804" y1="240" x2="804" y2="296" stroke="#2C1507" stroke-width="2"/>
                        <line x1="780" y1="268" x2="828" y2="268" stroke="#2C1507" stroke-width="2"/>
                    </g>

                    <!-- Pixel art windows on exterior (ground floor) -->
                    <g id="exterior-windows-ground">
                        <rect x="320" y="420" width="56" height="72" fill="#87CEEB" stroke="#2C1507" stroke-width="2"/>
                        <line x1="348" y1="420" x2="348" y2="492" stroke="#2C1507" stroke-width="2"/>
                        <line x1="320" y1="456" x2="376" y2="456" stroke="#2C1507" stroke-width="2"/>

                        <rect x="520" y="420" width="56" height="72" fill="#87CEEB" stroke="#2C1507" stroke-width="2"/>
                        <line x1="548" y1="420" x2="548" y2="492" stroke="#2C1507" stroke-width="2"/>
                        <line x1="520" y1="456" x2="576" y2="456" stroke="#2C1507" stroke-width="2"/>

                        <rect x="740" y="420" width="56" height="72" fill="#87CEEB" stroke="#2C1507" stroke-width="2"/>
                        <line x1="768" y1="420" x2="768" y2="492" stroke="#2C1507" stroke-width="2"/>
                        <line x1="740" y1="456" x2="796" y2="456" stroke="#2C1507" stroke-width="2"/>
                    </g>

                    <!-- FIRST FLOOR ROOMS (y: 200-350) -->
                    <!-- Main Bedroom (above Hall) -->
                    <rect x="100" y="200" width="160" height="150" fill="rgba(255,182,193,0.5)" stroke="#CC9933" stroke-width="3"/>
                    <text x="180" y="225" text-anchor="middle" font-size="14" font-weight="700" font-family="Fredoka" fill="#8B4513">Main Bedroom</text>

                    <!-- Landing -->
                    <rect x="260" y="200" width="160" height="150" fill="rgba(255,218,185,0.5)" stroke="#CC9933" stroke-width="3"/>
                    <text x="340" y="225" text-anchor="middle" font-size="14" font-weight="700" font-family="Fredoka" fill="#8B4513">Landing</text>
                    <!-- Stairs icon -->
                    <rect x="310" y="260" width="60" height="6" fill="rgba(139,69,19,0.6)"/>
                    <rect x="310" y="270" width="60" height="6" fill="rgba(139,69,19,0.6)"/>
                    <rect x="310" y="280" width="60" height="6" fill="rgba(139,69,19,0.6)"/>
                    <rect x="310" y="290" width="60" height="6" fill="rgba(139,69,19,0.6)"/>

                    <!-- Home Office -->
                    <rect x="420" y="200" width="160" height="150" fill="rgba(173,216,230,0.5)" stroke="#CC9933" stroke-width="3"/>
                    <text x="500" y="225" text-anchor="middle" font-size="14" font-weight="700" font-family="Fredoka" fill="#8B4513">Home Office</text>

                    <!-- Bathroom -->
                    <rect x="580" y="200" width="160" height="150" fill="rgba(152,251,152,0.5)" stroke="#CC9933" stroke-width="3"/>
                    <text x="660" y="225" text-anchor="middle" font-size="14" font-weight="700" font-family="Fredoka" fill="#8B4513">Bathroom</text>

                    <!-- Guest Bedroom -->
                    <rect x="740" y="200" width="160" height="150" fill="rgba(221,160,221,0.5)" stroke="#CC9933" stroke-width="3"/>
                    <text x="820" y="225" text-anchor="middle" font-size="14" font-weight="700" font-family="Fredoka" fill="#8B4513">Guest Bedroom</text>

                    <!-- GROUND FLOOR ROOMS (y: 350-600) -->
                    <!-- Hall (left, with door) -->
                    <rect x="100" y="350" width="200" height="250" fill="rgba(152,216,211,0.5)" stroke="#CC9933" stroke-width="4"/>
                    <text x="200" y="380" text-anchor="middle" font-size="16" font-weight="700" font-family="Fredoka" fill="#8B4513">Hall</text>
                    <!-- Front Door - pixel art style -->
                    <rect x="160" y="500" width="80" height="100" fill="#4A2511" stroke="#2C1507" stroke-width="3"/>
                    <!-- Door panels -->
                    <rect x="168" y="508" width="64" height="40" fill="#5D3116" stroke="#2C1507" stroke-width="1"/>
                    <rect x="168" y="552" width="64" height="40" fill="#5D3116" stroke="#2C1507" stroke-width="1"/>
                    <!-- Door handle -->
                    <circle cx="215" cy="560" r="4" fill="#FFD700" stroke="#CC9900" stroke-width="1"/>
                    <!-- Door letterbox -->
                    <rect x="180" y="530" width="40" height="6" fill="#2C1507"/>

                    <!-- House Number Plaque -->
                    <rect x="125" y="520" width="30" height="35" fill="#F5F5DC" stroke="#8B7355" stroke-width="2" rx="3"/>
                    <text x="140" y="542" text-anchor="middle" font-size="20" font-weight="700" font-family="Georgia, serif" fill="#2C1507">28</text>

                    <!-- Lounge -->
                    <rect x="300" y="350" width="200" height="250" fill="rgba(244,164,96,0.5)" stroke="#CC9933" stroke-width="4"/>
                    <text x="400" y="380" text-anchor="middle" font-size="16" font-weight="700" font-family="Fredoka" fill="#8B4513">Lounge</text>

                    <!-- Nest Thermostat on Lounge Wall -->
                    <g id="nest-thermostat-display" transform="translate(380, 470)">
                        <!-- Outer ring (metallic finish) -->
                        <circle cx="0" cy="0" r="45" fill="url(#nestMetalGradient)" stroke="#B8B8B8" stroke-width="2"/>

                        <!-- Inner display background -->
                        <circle id="nest-display-bg" cx="0" cy="0" r="38" fill="#000000"/>

                        <!-- Current temperature (large center) -->
                        <text id="nest-current-temp" x="0" y="8" text-anchor="middle"
                              font-size="28" font-weight="700" font-family="Arial, sans-serif"
                              fill="#FFFFFF">--</text>

                        <!-- Target temperature indicator (small, top) -->
                        <text id="nest-target-temp" x="0" y="-20" text-anchor="middle"
                              font-size="10" font-family="Arial, sans-serif"
                              fill="#888888">--</text>

                        <!-- Status text (bottom) -->
                        <text id="nest-status-text" x="0" y="28" text-anchor="middle"
                              font-size="8" font-family="Arial, sans-serif"
                              fill="#666666">OFF</text>

                        <!-- Heating/cooling indicator ring -->
                        <circle id="nest-status-ring" cx="0" cy="0" r="40"
                                fill="none" stroke="transparent" stroke-width="3" opacity="0.6"/>
                    </g>

                    <!-- Kitchen -->
                    <rect x="500" y="350" width="200" height="250" fill="rgba(255,179,71,0.5)" stroke="#CC9933" stroke-width="4"/>
                    <text x="600" y="380" text-anchor="middle" font-size="16" font-weight="700" font-family="Fredoka" fill="#8B4513">Kitchen</text>

                    <!-- Extension (right) -->
                    <rect x="700" y="350" width="200" height="250" fill="rgba(152,216,200,0.5)" stroke="#CC9933" stroke-width="4"/>
                    <text x="800" y="380" text-anchor="middle" font-size="16" font-weight="700" font-family="Fredoka" fill="#8B4513">Extension</text>
                </g>

                <!-- Thermometers will be dynamically added here by JavaScript -->
                <g id="thermometers-container"></g>

                <!-- Light indicators will be dynamically added here by JavaScript -->
                <g id="light-indicators-container"></g>

                <!-- Motion indicators will be dynamically added here by JavaScript -->
                <g id="motion-indicators-container"></g>

                <!-- Outdoor area (OUTSIDE the house) -->
                <g id="outdoor-area" transform="translate(30, 420)">
                    <!-- Tree -->
                    <rect x="10" y="70" width="20" height="90" rx="5" fill="#8B4513"/>
                    <circle cx="20" cy="60" r="45" fill="#2ECC71" opacity="0.8"/>
                    <circle cx="8" cy="45" r="38" fill="#27AE60" opacity="0.8"/>
                    <circle cx="32" cy="45" r="38" fill="#27AE60" opacity="0.8"/>

                    <!-- Narnia-style Lamppost -->
                    <g id="outdoor-lamppost">
                        <!-- Base -->
                        <rect x="140" y="140" width="30" height="8" fill="#2C3E50" rx="2"/>
                        <rect x="145" y="148" width="20" height="8" fill="#34495E" rx="1"/>

                        <!-- Post -->
                        <rect x="150" y="65" width="10" height="83" fill="#34495E" rx="2"/>
                        <rect x="148" y="65" width="14" height="4" fill="#2C3E50"/>

                        <!-- Ornate top piece -->
                        <rect x="148" y="50" width="14" height="15" fill="#2C3E50" rx="1"/>

                        <!-- Lamp housing (glass panels) -->
                        <g id="lamp-housing">
                            <!-- Top -->
                            <polygon points="155,35 165,50 145,50" fill="#8B4513"/>

                            <!-- Glass panels (will change based on on/off) -->
                            <rect x="148" y="50" width="4" height="12" fill="#1a1a1a" opacity="0.3" id="lamp-panel-1"/>
                            <rect x="158" y="50" width="4" height="12" fill="#1a1a1a" opacity="0.3" id="lamp-panel-2"/>
                            <rect x="150" y="50" width="10" height="12" fill="#1a1a1a" opacity="0.2" id="lamp-panel-center"/>

                            <!-- Light bulb inside (will glow when on) -->
                            <circle cx="155" cy="56" r="6" fill="#666" id="lamp-bulb"/>

                            <!-- Frame lines -->
                            <rect x="148" y="50" width="14" height="12" fill="none" stroke="#2C3E50" stroke-width="1.5"/>
                            <line x1="152" y1="50" x2="152" y2="62" stroke="#2C3E50" stroke-width="1"/>
                            <line x1="158" y1="50" x2="158" y2="62" stroke="#2C3E50" stroke-width="1"/>
                        </g>

                        <!-- Decorative scrollwork -->
                        <path d="M 155 65 Q 145 68 145 73" fill="none" stroke="#2C3E50" stroke-width="1.5"/>
                        <path d="M 155 65 Q 165 68 165 73" fill="none" stroke="#2C3E50" stroke-width="1.5"/>
                    </g>

                    <!-- Outdoor thermometer will be added here by JavaScript -->
                    <g id="outdoor-thermometer-container"></g>
                </g>

                <!-- Flowers in garden -->
                <g transform="translate(150, 590)">
                    <circle cx="0" cy="0" r="7" fill="#FF69B4"/>
                    <circle cx="25" cy="4" r="7" fill="#FF1493"/>
                    <circle cx="50" cy="-2" r="7" fill="#FF69B4"/>
                    <rect x="-2" y="0" width="2.5" height="25" fill="#228B22"/>
                    <rect x="23" y="4" width="2.5" height="20" fill="#228B22"/>
                    <rect x="48" y="-2" width="2.5" height="27" fill="#228B22"/>
                </g>

                <g transform="translate(750, 598)">
                    <circle cx="0" cy="0" r="7" fill="#FFD700"/>
                    <circle cx="22" cy="2" r="7" fill="#FFA500"/>
                    <circle cx="44" cy="-1" r="7" fill="#FFD700"/>
                    <rect x="-2" y="0" width="2.5" height="23" fill="#228B22"/>
                    <rect x="20" y="2" width="2.5" height="20" fill="#228B22"/>
                    <rect x="42" y="-1" width="2.5" height="25" fill="#228B22"/>
                </g>

                <!-- Moose character container (dynamically populated) -->
                <g id="moose-container"></g>
            </svg>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-label">üè† Average Indoor</div>
                <div class="stat-value" id="avg-temp">--¬∞C</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">üî• Warmest Room</div>
                <div class="stat-value" id="max-temp">--¬∞C</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">‚ùÑÔ∏è Coolest Room</div>
                <div class="stat-value" id="min-temp">--¬∞C</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">üìä Temp Range</div>
                <div class="stat-value" id="range-temp">--¬∞C</div>
            </div>
            <div class="stat-card weather-card">
                <div class="stat-label">üå§Ô∏è Outdoor Weather</div>
                <div class="weather-main">
                    <img id="weather-icon" src="" alt="" class="weather-icon">
                    <div class="weather-temp-container">
                        <div class="stat-value" id="weather-temp">--¬∞C</div>
                        <div class="weather-condition" id="weather-condition">Loading...</div>
                    </div>
                </div>
                <div class="weather-details">
                    <div id="weather-feels">Feels like --¬∞C</div>
                    <div class="weather-extra">
                        <span id="weather-humidity">üíß --%</span>
                        <span id="weather-uv">‚òÄÔ∏è UV -</span>
                    </div>
                </div>
            </div>
        </div>

        <button class="refresh-btn" onclick="loadTemperatures()" id="refreshBtn">
            üîÑ Refresh Temps!
        </button>

        <!-- Fun Action Buttons -->
        <div style="display: flex; gap: 10px; justify-content: center; margin-top: 15px; flex-wrap: wrap;">
            <button class="refresh-btn" onclick="redAlert()" id="redAlertBtn" style="background: linear-gradient(135deg, #FF0000 0%, #8B0000 100%);">
                üö® Red Alert
            </button>
            <button class="refresh-btn" onclick="partyMode()" id="partyBtn" style="background: linear-gradient(135deg, #FF00FF 0%, #00FFFF 100%);">
                üéâ Party Mode
            </button>
            <button class="refresh-btn" onclick="discoMode()" id="discoBtn" style="background: linear-gradient(135deg, #FFD700 0%, #FF1493 100%);">
                üï∫ Disco
            </button>
            <button class="refresh-btn" onclick="waveEffect()" id="waveBtn" style="background: linear-gradient(135deg, #4169E1 0%, #1E90FF 100%);">
                üåä Wave
            </button>
            <button class="refresh-btn" onclick="sunsetMode()" id="sunsetBtn" style="background: linear-gradient(135deg, #FF6B35 0%, #FF8E53 100%);">
                üåÖ Sunset
            </button>
            <button class="refresh-btn" onclick="resetThermometerPositions()" id="resetBtn" style="background: linear-gradient(135deg, #6C757D 0%, #495057 100%);">
                üîÑ Reset Thermometers
            </button>
        </div>

        <!-- Sensor Details Panel -->
        <div class="graph-container" style="margin-top: 20px;">
            <h2 class="graph-title section-header" onclick="toggleSection('sensor-details-content', 'sensor-arrow')">
                <span class="section-arrow collapsed" id="sensor-arrow">‚ñº</span>
                üì° Sensor Details
            </h2>
            <div id="sensor-details-content" class="collapsible-content collapsed">
                <div id="sensor-details" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; padding: 15px;">
                    <div style="text-align: center; color: #999; padding: 20px;">Loading sensor data...</div>
                </div>
            </div>
        </div>

        <!-- Motion Detection Log -->
        <div class="graph-container" style="margin-top: 20px;">
            <h2 class="graph-title section-header" onclick="toggleSection('motion-log-content', 'motion-arrow')">
                <span class="section-arrow collapsed" id="motion-arrow">‚ñº</span>
                üö∂ 48-Hour Motion Detection Log
            </h2>
            <div id="motion-log-content" class="collapsible-content collapsed">
                <div id="motion-log" style="max-height: 300px; overflow-y: auto; padding: 15px; background: #f9f9f9; border-radius: 10px; font-family: 'Courier New', monospace; font-size: 13px;">
                    <div style="text-align: center; color: #999; padding: 20px;">Loading motion history...</div>
                </div>
                <div style="text-align: center; margin-top: 10px; font-size: 12px; color: #666;">
                    <span id="motion-log-count">0</span> events in last 48 hours
                </div>
            </div>
        </div>

        <!-- Temperature Graph -->
        <div class="graph-container">
            <h2 class="graph-title">üìà 24-Hour Temperature History</h2>
            <svg id="temp-graph" viewBox="0 0 1200 400" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <linearGradient id="gridGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" style="stop-color:#f0f0f0;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#ffffff;stop-opacity:1" />
                    </linearGradient>
                </defs>
                <!-- Background -->
                <rect width="1200" height="400" fill="url(#gridGradient)" rx="10"/>

                <!-- Grid lines will be added by JavaScript -->
                <g id="grid-lines"></g>

                <!-- Graph lines will be added by JavaScript -->
                <g id="graph-lines"></g>

                <!-- Axes -->
                <line x1="50" y1="350" x2="1150" y2="350" stroke="#ccc" stroke-width="2"/>
                <line x1="50" y1="50" x2="50" y2="350" stroke="#ccc" stroke-width="2"/>

                <!-- Labels will be added by JavaScript -->
                <g id="axis-labels"></g>
                <g id="legend"></g>
            </svg>
        </div>
    </div>

    <script src="config.js"></script>
    <script src="nest-config.js"></script>
    <script>
        const BRIDGE_IP = HUE_CONFIG.BRIDGE_IP;
        const USERNAME = HUE_CONFIG.USERNAME;

        const sensorMapping = {
            // First Floor
            'landing': 'temp-landing',
            'main bedroom': 'temp-main-bedroom',
            'guest room': 'temp-guest-bedroom',
            'Hue temperature sensor 1': 'temp-office',  // Home Office
            'bathroom': 'temp-bathroom',
            // Ground Floor
            'Hall': 'temp-hall',
            'lounge': 'temp-lounge',
            'ExtensionDimmer': 'temp-extension',
            'guest room': 'temp-guest-bedroom',
            'KitchenSensor': 'temp-kitchen',
            // Outdoor
            'Hue outdoor temp. sensor 1': 'temp-outdoor'
        };

        const roomColors = {
            // First Floor
            'landing': '#FF6B9D',
            'main bedroom': '#FFB6C1',
            'guest room': '#DDA0DD',
            'Hue temperature sensor 1': '#87CEEB',
            'bathroom': '#4ECDC4',
            // Ground Floor
            'Hall': '#95E1D3',
            'lounge': '#F4A460',
            'ExtensionDimmer': '#98D8C8',
            'KitchenSensor': '#FFB347',
            // Outdoor
            'Hue outdoor temp. sensor 1': '#7AE582'
        };

        const roomNames = {
            // First Floor
            'landing': 'Landing',
            'main bedroom': 'Main Bedroom',
            'guest room': 'Guest Bedroom',
            'Hue temperature sensor 1': 'Home Office',
            'bathroom': 'Bathroom',
            // Ground Floor
            'Hall': 'Hall',
            'lounge': 'Lounge',
            'ExtensionDimmer': 'Extension',
            'KitchenSensor': 'Kitchen',
            // Outdoor
            'Hue outdoor temp. sensor 1': 'Outdoor'
        };

        // Light bulb mapping to rooms (will be populated dynamically)
        const lightMapping = {};

        // Store light states for each room
        const roomLights = {
            'Main Bedroom': [],
            'Guest Bedroom': [],
            'Landing': [],
            'Home Office': [],
            'Bathroom': [],
            'Lounge': [],
            'Hall': [],
            'Extension': [],
            'Kitchen': [],
            'Outdoor': []
        };

        // Track previous light states for announcements
        const previousLightStates = {};

        // Store motion sensor states
        const motionSensors = {
            'Outdoor': { detected: false, lastUpdated: null, previousDetected: false },
            'Hall': { detected: false, lastUpdated: null, previousDetected: false },
            'Landing': { detected: false, lastUpdated: null, previousDetected: false },
            'Bathroom': { detected: false, lastUpdated: null, previousDetected: false }
        };

        // Motion detection history (48 hours)
        let motionHistory = [];

        // Initialize motion history from localStorage
        function initMotionHistory() {
            const stored = localStorage.getItem('motionHistory');
            if (stored) {
                motionHistory = JSON.parse(stored);
                // Clean old data (older than 48 hours)
                const now = Date.now();
                const twoDaysAgo = now - (48 * 60 * 60 * 1000);
                motionHistory = motionHistory.filter(entry => entry.time > twoDaysAgo);
                localStorage.setItem('motionHistory', JSON.stringify(motionHistory));
            }
            updateMotionLogDisplay();
        }

        // Log a motion detection event
        function logMotionEvent(room) {
            const now = Date.now();
            motionHistory.push({
                time: now,
                room: room
            });

            // Keep only last 48 hours
            const twoDaysAgo = now - (48 * 60 * 60 * 1000);
            motionHistory = motionHistory.filter(entry => entry.time > twoDaysAgo);

            // Save to localStorage
            localStorage.setItem('motionHistory', JSON.stringify(motionHistory));

            // Update display
            updateMotionLogDisplay();
        }

        // Update the motion log display
        function updateMotionLogDisplay() {
            const logContainer = document.getElementById('motion-log');
            const countDisplay = document.getElementById('motion-log-count');

            if (!logContainer) return;

            // Get colors from CSS variables
            const styles = getComputedStyle(document.documentElement);
            const textLight = styles.getPropertyValue('--text-light').trim();
            const textPrimary = styles.getPropertyValue('--text-primary').trim();

            // Count display
            countDisplay.textContent = motionHistory.length;

            if (motionHistory.length === 0) {
                logContainer.innerHTML = `<div style="text-align: center; color: ${textLight}; padding: 20px;">No motion events recorded yet</div>`;
                return;
            }

            // Sort by most recent first
            const sortedHistory = [...motionHistory].sort((a, b) => b.time - a.time);

            // Group by date
            const groupedByDate = {};
            sortedHistory.forEach(entry => {
                const date = new Date(entry.time);
                const dateKey = date.toLocaleDateString();
                if (!groupedByDate[dateKey]) {
                    groupedByDate[dateKey] = [];
                }
                groupedByDate[dateKey].push(entry);
            });

            // Build HTML
            let html = '';
            for (const [dateKey, events] of Object.entries(groupedByDate)) {
                html += `<div style="margin-bottom: 15px;">`;
                html += `<div style="font-weight: bold; color: ${textPrimary}; margin-bottom: 8px; font-family: 'Fredoka', sans-serif;">üìÖ ${dateKey}</div>`;

                events.forEach(entry => {
                    const date = new Date(entry.time);
                    const timeStr = date.toLocaleTimeString();
                    const roomEmoji = {
                        'Outdoor': 'üå≥',
                        'Hall': 'üö™',
                        'Landing': 'ü™ú',
                        'Bathroom': 'üöø'
                    };
                    const emoji = roomEmoji[entry.room] || 'üö∂';

                    // Calculate how long ago
                    const now = Date.now();
                    const diff = now - entry.time;
                    const hours = Math.floor(diff / (60 * 60 * 1000));
                    const minutes = Math.floor((diff % (60 * 60 * 1000)) / (60 * 1000));
                    let ago = '';
                    if (hours > 0) {
                        ago = `${hours}h ${minutes}m ago`;
                    } else if (minutes > 0) {
                        ago = `${minutes}m ago`;
                    } else {
                        ago = 'just now';
                    }

                    html += `<div style="padding: 6px 10px; margin: 4px 0; background: ${styles.getPropertyValue('--bg-graph').trim()}; border-radius: 6px; border-left: 3px solid ${textPrimary}; display: flex; justify-content: space-between; align-items: center;">`;
                    html += `<span style="color: ${textPrimary};">${emoji} <strong>${entry.room}</strong> - ${timeStr}</span>`;
                    html += `<span style="color: ${textLight}; font-size: 11px;">${ago}</span>`;
                    html += `</div>`;
                });

                html += `</div>`;
            }

            logContainer.innerHTML = html;

            // Auto-scroll to top (most recent)
            logContainer.scrollTop = 0;
        }

        // Voice announcement function for motion
        function announceMotion(room) {
            // Use Web Speech API for local voice announcement
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance();

                // Different messages for different locations
                const messages = {
                    'Outdoor': 'Motion detected outside',
                    'Hall': 'Motion detected in the hall',
                    'Landing': 'Motion detected on the landing',
                    'Bathroom': 'Motion detected in the bathroom'
                };

                utterance.text = messages[room] || `Motion detected in ${room}`;
                utterance.rate = 1.1; // Slightly faster for urgency
                utterance.pitch = 1.0;
                utterance.volume = 1.0;

                // Cancel any ongoing speech and speak
                window.speechSynthesis.cancel();
                window.speechSynthesis.speak(utterance);
            } else {
                // Fallback: play a beep sound if speech not available
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = 800;
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            }
        }

        // Voice announcement function for lights
        function announceLight(room, isOn) {
            // Don't announce during light effects to avoid spam
            if (effectInProgress) {
                return;
            }

            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance();

                const action = isOn ? 'on' : 'off';
                const roomName = room.toLowerCase();

                utterance.text = `${room} light turned ${action}`;
                utterance.rate = 1.0;
                utterance.pitch = 1.0;
                utterance.volume = 0.8;

                // Don't cancel ongoing speech, queue it instead
                window.speechSynthesis.speak(utterance);

                console.log(`üí° Announced: ${room} light ${action}`);
            }
        }

        // Temperature history storage
        let tempHistory = {};

        function initTempHistory() {
            const stored = localStorage.getItem('tempHistory');
            if (stored) {
                tempHistory = JSON.parse(stored);
                // Clean old data (older than 24 hours)
                const now = Date.now();
                const oneDayAgo = now - (24 * 60 * 60 * 1000);
                for (let room in tempHistory) {
                    tempHistory[room] = tempHistory[room].filter(entry => entry.time > oneDayAgo);
                }
            } else {
                for (let room in sensorMapping) {
                    tempHistory[room] = [];
                }
            }
        }

        function saveTempData(room, temp) {
            const now = Date.now();
            if (!tempHistory[room]) {
                tempHistory[room] = [];
            }
            tempHistory[room].push({ time: now, temp: parseFloat(temp) });

            // Keep only last 24 hours
            const oneDayAgo = now - (24 * 60 * 60 * 1000);
            tempHistory[room] = tempHistory[room].filter(entry => entry.time > oneDayAgo);

            localStorage.setItem('tempHistory', JSON.stringify(tempHistory));
        }

        function drawGraph() {
            const graphLines = document.getElementById('graph-lines');
            const gridLines = document.getElementById('grid-lines');
            const axisLabels = document.getElementById('axis-labels');
            const legend = document.getElementById('legend');

            // Clear existing elements
            graphLines.innerHTML = '';
            gridLines.innerHTML = '';
            axisLabels.innerHTML = '';
            legend.innerHTML = '';

            const now = Date.now();
            const oneDayAgo = now - (24 * 60 * 60 * 1000);

            // Graph dimensions
            const width = 1100;
            const height = 300;
            const marginLeft = 50;
            const marginBottom = 50;

            // Find min/max temps across all rooms
            let minTemp = Infinity;
            let maxTemp = -Infinity;

            for (let room in tempHistory) {
                tempHistory[room].forEach(entry => {
                    if (entry.temp < minTemp) minTemp = entry.temp;
                    if (entry.temp > maxTemp) maxTemp = entry.temp;
                });
            }

            if (minTemp === Infinity) {
                minTemp = 0;
                maxTemp = 30;
            } else {
                minTemp = Math.floor(minTemp) - 2;
                maxTemp = Math.ceil(maxTemp) + 2;
            }

            // Draw grid lines
            const tempRange = maxTemp - minTemp;
            for (let i = 0; i <= 5; i++) {
                const temp = minTemp + (tempRange * i / 5);
                const y = 350 - (temp - minTemp) / tempRange * height;

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', marginLeft);
                line.setAttribute('y1', y);
                line.setAttribute('x2', marginLeft + width);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#e0e0e0');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('stroke-dasharray', '5,5');
                gridLines.appendChild(line);

                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', marginLeft - 10);
                label.setAttribute('y', y + 5);
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('font-size', '12');
                label.setAttribute('fill', '#666');
                label.textContent = temp.toFixed(1) + '¬∞C';
                axisLabels.appendChild(label);
            }

            // Draw time labels (every 4 hours)
            for (let i = 0; i <= 6; i++) {
                const time = oneDayAgo + (24 * 60 * 60 * 1000 * i / 6);
                const x = marginLeft + (width * i / 6);
                const date = new Date(time);
                const hours = date.getHours().toString().padStart(2, '0');

                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', 370);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('font-size', '12');
                label.setAttribute('fill', '#666');
                label.textContent = hours + ':00';
                axisLabels.appendChild(label);
            }

            // Draw lines for each room
            let legendY = 70;
            for (let room in tempHistory) {
                const data = tempHistory[room];
                if (data.length < 2) continue;

                const color = roomColors[room] || '#999';
                const points = [];

                data.forEach(entry => {
                    const x = marginLeft + ((entry.time - oneDayAgo) / (24 * 60 * 60 * 1000)) * width;
                    const y = 350 - ((entry.temp - minTemp) / tempRange) * height;
                    points.push(`${x},${y}`);
                });

                const pathData = 'M' + points.join(' L');
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('class', 'graph-line');
                path.setAttribute('stroke', color);

                // Calculate path length for animation
                const pathLength = path.getTotalLength();
                path.style.strokeDasharray = pathLength;
                path.style.strokeDashoffset = pathLength;
                path.style.animation = `draw-line 2s ease-out forwards`;

                graphLines.appendChild(path);

                // Draw points
                data.forEach(entry => {
                    const x = marginLeft + ((entry.time - oneDayAgo) / (24 * 60 * 60 * 1000)) * width;
                    const y = 350 - ((entry.temp - minTemp) / tempRange) * height;

                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', 4);
                    circle.setAttribute('fill', color);
                    circle.setAttribute('class', 'graph-point');
                    circle.style.opacity = 0;
                    circle.style.animation = `fade-in 0.5s ease-out ${2 + (x / width) * 0.5}s forwards`;

                    const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                    const date = new Date(entry.time);
                    title.textContent = `${roomNames[room]}: ${entry.temp}¬∞C at ${date.toLocaleTimeString()}`;
                    circle.appendChild(title);

                    graphLines.appendChild(circle);
                });

                // Legend
                const legendRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                legendRect.setAttribute('x', 900);
                legendRect.setAttribute('y', legendY - 10);
                legendRect.setAttribute('width', 20);
                legendRect.setAttribute('height', 4);
                legendRect.setAttribute('fill', color);
                legend.appendChild(legendRect);

                const legendText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                legendText.setAttribute('x', 930);
                legendText.setAttribute('y', legendY);
                legendText.setAttribute('font-size', '14');
                legendText.setAttribute('font-weight', '600');
                legendText.setAttribute('fill', '#333');
                legendText.setAttribute('font-family', 'Fredoka');
                legendText.textContent = roomNames[room];
                legend.appendChild(legendText);

                legendY += 25;
            }

            // Add fade-in animation for points
            if (!document.getElementById('fade-in-style')) {
                const style = document.createElement('style');
                style.id = 'fade-in-style';
                style.textContent = `
                    @keyframes fade-in {
                        to { opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
            }
        }

        // Room positions for thermometers (bulb positioned inside each room)
        const roomPositions = {
            // First Floor (y: 200-350) - bulbs near bottom of rooms
            'temp-main-bedroom': { x: 180, y: 220 },
            'temp-landing': { x: 340, y: 220 },
            'temp-office': { x: 500, y: 220 },
            'temp-bathroom': { x: 660, y: 220 },
            'temp-guest-bedroom': { x: 820, y: 220 },
            // Ground Floor (y: 350-600) - bulbs in middle/lower section
            'temp-hall': { x: 200, y: 460 },
            'temp-lounge': { x: 400, y: 460 },
            'temp-kitchen': { x: 600, y: 460 },
            'temp-extension': { x: 800, y: 460 },
            // Outdoor (relative to outdoor-area transform)
            'temp-outdoor': { x: 60, y: 10, isOutdoor: true }
        };

        // Load custom thermometer positions from localStorage
        let customThermometerPositions = JSON.parse(
            localStorage.getItem('thermometerPositions') || '{}'
        );

        // Get position with custom override support
        function getThermometerPosition(elementId) {
            return customThermometerPositions[elementId] || roomPositions[elementId];
        }

        function getTemperatureColor(temp) {
            if (temp < 10) return '#4169E1';  // Royal Blue - Cold
            if (temp < 15) return '#00CED1';  // Dark Turquoise - Cool
            if (temp < 20) return '#32CD32';  // Lime Green - Comfortable
            if (temp < 25) return '#FFA500';  // Orange - Warm
            return '#FF4500';  // Orange Red - Hot
        }

        function createThermometer(elementId, temp, roomName) {
            const position = getThermometerPosition(elementId);
            if (!position) return null;

            const ns = 'http://www.w3.org/2000/svg';
            const group = document.createElementNS(ns, 'g');
            group.setAttribute('class', 'thermometer');
            group.setAttribute('data-room', elementId);

            // Thermometer dimensions
            const tubeWidth = 24;
            const tubeHeight = 80;
            const bulbRadius = 16;

            // Background (glass tube)
            const tube = document.createElementNS(ns, 'rect');
            tube.setAttribute('x', 0);
            tube.setAttribute('y', 0);
            tube.setAttribute('width', tubeWidth);
            tube.setAttribute('height', tubeHeight);
            tube.setAttribute('rx', 12);
            tube.setAttribute('fill', 'rgba(255, 255, 255, 0.9)');
            tube.setAttribute('stroke', '#666');
            tube.setAttribute('stroke-width', '2');
            tube.setAttribute('filter', 'url(#shadow)');
            group.appendChild(tube);

            // Bulb
            const bulb = document.createElementNS(ns, 'circle');
            bulb.setAttribute('cx', tubeWidth / 2);
            bulb.setAttribute('cy', tubeHeight + bulbRadius - 4);
            bulb.setAttribute('r', bulbRadius);
            bulb.setAttribute('fill', 'rgba(255, 255, 255, 0.9)');
            bulb.setAttribute('stroke', '#666');
            bulb.setAttribute('stroke-width', '2');
            bulb.setAttribute('filter', 'url(#shadow)');
            group.appendChild(bulb);

            // Mercury level (0-30¬∞C range for visualization)
            const tempRange = { min: 0, max: 30 };
            const percentage = Math.max(0, Math.min(1, (temp - tempRange.min) / (tempRange.max - tempRange.min)));
            const mercuryHeight = (tubeHeight - 10) * percentage + bulbRadius * 2 - 4;

            const mercuryColor = position.isOutdoor ? '#00CED1' : getTemperatureColor(temp);

            // Mercury in bulb
            const mercuryBulb = document.createElementNS(ns, 'circle');
            mercuryBulb.setAttribute('cx', tubeWidth / 2);
            mercuryBulb.setAttribute('cy', tubeHeight + bulbRadius - 4);
            mercuryBulb.setAttribute('r', bulbRadius - 4);
            mercuryBulb.setAttribute('fill', mercuryColor);
            mercuryBulb.setAttribute('class', 'mercury-fill');
            group.appendChild(mercuryBulb);

            // Mercury in tube
            const mercuryTube = document.createElementNS(ns, 'rect');
            mercuryTube.setAttribute('x', tubeWidth / 2 - 4);
            mercuryTube.setAttribute('y', tubeHeight - mercuryHeight + bulbRadius);
            mercuryTube.setAttribute('width', 8);
            mercuryTube.setAttribute('height', mercuryHeight - bulbRadius);
            mercuryTube.setAttribute('rx', 4);
            mercuryTube.setAttribute('fill', mercuryColor);
            mercuryTube.setAttribute('class', 'mercury-fill');
            group.appendChild(mercuryTube);

            // Scale markings
            for (let i = 0; i <= 4; i++) {
                const y = tubeHeight - (tubeHeight - 10) * (i / 4) + 5;
                const mark = document.createElementNS(ns, 'line');
                mark.setAttribute('x1', tubeWidth);
                mark.setAttribute('y1', y);
                mark.setAttribute('x2', tubeWidth + 5);
                mark.setAttribute('y2', y);
                mark.setAttribute('stroke', '#666');
                mark.setAttribute('stroke-width', '1');
                group.appendChild(mark);
            }

            // Temperature text
            const tempText = document.createElementNS(ns, 'text');
            tempText.setAttribute('x', tubeWidth / 2);
            tempText.setAttribute('y', tubeHeight + bulbRadius * 2 + 20);
            tempText.setAttribute('text-anchor', 'middle');
            tempText.setAttribute('font-size', '18');
            tempText.setAttribute('font-weight', '700');
            tempText.setAttribute('font-family', 'Baloo 2');
            tempText.setAttribute('fill', 'white');
            tempText.setAttribute('stroke', '#333');
            tempText.setAttribute('stroke-width', '3');
            tempText.setAttribute('paint-order', 'stroke fill');
            tempText.setAttribute('id', elementId);
            tempText.textContent = temp.toFixed(1) + '¬∞C';
            group.appendChild(tempText);

            // Room label
            const label = document.createElementNS(ns, 'text');
            label.setAttribute('x', tubeWidth / 2);
            label.setAttribute('y', -8);
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('font-size', position.isOutdoor ? '12' : '11');
            label.setAttribute('font-weight', position.isOutdoor ? '700' : '600');
            label.setAttribute('font-family', 'Fredoka');
            label.setAttribute('fill', position.isOutdoor ? '#0066CC' : '#333');
            label.textContent = roomName;
            group.appendChild(label);

            // Position the thermometer
            if (position.isOutdoor) {
                group.setAttribute('transform', `translate(${position.x}, ${position.y})`);
                document.getElementById('outdoor-thermometer-container').appendChild(group);
            } else {
                group.setAttribute('transform', `translate(${position.x}, ${position.y})`);
                document.getElementById('thermometers-container').appendChild(group);
            }

            // Make thermometer draggable
            makeDraggable(group, elementId, position);

            return tempText;
        }

        function makeDraggable(group, elementId, position) {
            let isDragging = false;
            let startX, startY, currentTransform;

            group.style.cursor = 'move';

            // Unified start handler for both mouse and touch
            function handleStart(e) {
                isDragging = true;

                // Get coordinates from either mouse or touch event
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                startX = clientX;
                startY = clientY;

                const transform = group.getAttribute('transform');
                const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                currentTransform = {
                    x: parseFloat(match[1]),
                    y: parseFloat(match[2])
                };

                group.style.opacity = '0.7';
                e.preventDefault();
                e.stopPropagation();
            }

            // Unified move handler
            function handleMove(e) {
                if (!isDragging) return;

                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                const dx = clientX - startX;
                const dy = clientY - startY;
                const newX = currentTransform.x + dx;
                const newY = currentTransform.y + dy;

                group.setAttribute('transform', `translate(${newX}, ${newY})`);
            }

            // Unified end handler
            function handleEnd(e) {
                if (!isDragging) return;
                isDragging = false;

                group.style.opacity = '1';

                // Save position to localStorage
                const transform = group.getAttribute('transform');
                const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);

                customThermometerPositions[elementId] = {
                    x: parseFloat(match[1]),
                    y: parseFloat(match[2]),
                    isOutdoor: position.isOutdoor
                };

                localStorage.setItem(
                    'thermometerPositions',
                    JSON.stringify(customThermometerPositions)
                );
            }

            // Add both mouse and touch event listeners
            group.addEventListener('mousedown', handleStart);
            group.addEventListener('touchstart', handleStart, { passive: false });

            document.addEventListener('mousemove', handleMove);
            document.addEventListener('touchmove', handleMove, { passive: false });

            document.addEventListener('mouseup', handleEnd);
            document.addEventListener('touchend', handleEnd);
        }

        function resetThermometerPositions() {
            if (confirm('Reset all thermometer positions to defaults?')) {
                localStorage.removeItem('thermometerPositions');
                location.reload();
            }
        }

        function createSparkles(element) {
            const rect = element.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const sparkleEmojis = ['‚ú®', '‚≠ê', 'üåü', 'üí´', '‚ú®', '‚≠ê'];
            const numSparkles = 8;

            for (let i = 0; i < numSparkles; i++) {
                const sparkle = document.createElement('div');
                sparkle.className = 'sparkle-star';
                sparkle.textContent = sparkleEmojis[Math.floor(Math.random() * sparkleEmojis.length)];

                const angle = (Math.PI * 2 * i) / numSparkles;
                const distance = 50 + Math.random() * 30;
                const tx = Math.cos(angle) * distance;
                const ty = Math.sin(angle) * distance;

                sparkle.style.left = centerX + 'px';
                sparkle.style.top = centerY + 'px';
                sparkle.style.setProperty('--tx', tx + 'px');
                sparkle.style.setProperty('--ty', ty + 'px');

                document.body.appendChild(sparkle);

                setTimeout(() => sparkle.remove(), 1000);
            }
        }

        function mapLightToRoom(lightName) {
            const nameLower = lightName.toLowerCase();

            if (nameLower.includes('outdoor') || nameLower.includes('outside') || nameLower.includes('garden')) return 'Outdoor';

            // Guest bedroom must be checked BEFORE main bedroom to avoid conflicts
            if (nameLower.includes('guest')) return 'Guest Bedroom';

            // Main bedroom - check for various naming patterns
            if (nameLower.includes('main bedroom') || nameLower.includes('mainbedroom') ||
                nameLower === 'bedroomlight' || nameLower === 'bedroom') return 'Main Bedroom';

            if (nameLower.includes('landing')) return 'Landing';
            if (nameLower.includes('office')) return 'Home Office';
            if (nameLower.includes('bathroom') || nameLower.includes('bath')) return 'Bathroom';
            if (nameLower.includes('lounge')) return 'Lounge';
            if (nameLower.includes('hall')) return 'Hall';
            if (nameLower.includes('extension')) return 'Extension';
            if (nameLower.includes('kitchen')) return 'Kitchen';

            return null;
        }

        function updateOutdoorLamppost(isOn) {
            const bulb = document.getElementById('lamp-bulb');
            const panel1 = document.getElementById('lamp-panel-1');
            const panel2 = document.getElementById('lamp-panel-2');
            const panelCenter = document.getElementById('lamp-panel-center');
            const lampHousing = document.getElementById('lamp-housing');

            if (!bulb) return;

            // Make lamppost clickable
            if (lampHousing) {
                lampHousing.style.cursor = 'pointer';
            }

            if (isOn) {
                // Light is ON - glow effect
                bulb.setAttribute('fill', '#FFD700');
                bulb.setAttribute('filter', 'url(#glow)');
                panel1.setAttribute('fill', '#FFF4CC');
                panel1.setAttribute('opacity', '0.9');
                panel2.setAttribute('fill', '#FFF4CC');
                panel2.setAttribute('opacity', '0.9');
                panelCenter.setAttribute('fill', '#FFEB99');
                panelCenter.setAttribute('opacity', '0.8');

                // Add light rays
                let rays = document.getElementById('lamp-rays');
                if (!rays) {
                    const ns = 'http://www.w3.org/2000/svg';
                    rays = document.createElementNS(ns, 'g');
                    rays.setAttribute('id', 'lamp-rays');
                    rays.setAttribute('opacity', '0.4');

                    // Create radiating light
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * 45) * Math.PI / 180;
                        const x1 = 155, y1 = 56;
                        const x2 = 155 + Math.cos(angle) * 30;
                        const y2 = 56 + Math.sin(angle) * 30;

                        const ray = document.createElementNS(ns, 'line');
                        ray.setAttribute('x1', x1);
                        ray.setAttribute('y1', y1);
                        ray.setAttribute('x2', x2);
                        ray.setAttribute('y2', y2);
                        ray.setAttribute('stroke', '#FFD700');
                        ray.setAttribute('stroke-width', '2');
                        ray.setAttribute('stroke-linecap', 'round');

                        rays.appendChild(ray);
                    }

                    document.getElementById('lamp-housing').appendChild(rays);
                }
                rays.style.display = 'block';
            } else {
                // Light is OFF - dark
                bulb.setAttribute('fill', '#666');
                bulb.removeAttribute('filter');
                panel1.setAttribute('fill', '#1a1a1a');
                panel1.setAttribute('opacity', '0.3');
                panel2.setAttribute('fill', '#1a1a1a');
                panel2.setAttribute('opacity', '0.3');
                panelCenter.setAttribute('fill', '#1a1a1a');
                panelCenter.setAttribute('opacity', '0.2');

                const rays = document.getElementById('lamp-rays');
                if (rays) rays.style.display = 'none';
            }
        }

        async function toggleLight(lightId, currentState) {
            try {
                const newState = !currentState;

                // Send command to Hue Bridge
                const response = await fetch(`http://${BRIDGE_IP}/api/${USERNAME}/lights/${lightId}/state`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ on: newState })
                });

                if (response.ok) {
                    console.log(`Light ${lightId} toggled to ${newState ? 'ON' : 'OFF'}`);
                    // Refresh lights after a short delay
                    setTimeout(loadLights, 500);
                } else {
                    console.error('Failed to toggle light');
                }
            } catch (error) {
                console.error('Error toggling light:', error);
            }
        }

        async function loadLights() {
            try {
                const response = await fetch(`http://${BRIDGE_IP}/api/${USERNAME}/lights`);
                if (!response.ok) return;

                const lights = await response.json();

                // Clear previous light data
                for (let room in roomLights) {
                    roomLights[room] = [];
                }

                // Map lights to rooms and detect changes
                for (const [lightId, lightInfo] of Object.entries(lights)) {
                    const room = mapLightToRoom(lightInfo.name);
                    if (room && roomLights[room]) {
                        const currentState = lightInfo.state.on;

                        // Check if this light's state changed
                        if (previousLightStates[lightId] !== undefined &&
                            previousLightStates[lightId] !== currentState &&
                            lightInfo.state.reachable) {
                            // Light state changed - announce it
                            announceLight(room, currentState);
                        }

                        // Update previous state
                        previousLightStates[lightId] = currentState;

                        roomLights[room].push({
                            id: lightId,
                            name: lightInfo.name,
                            on: currentState,
                            reachable: lightInfo.state.reachable
                        });
                    }
                }

                // Update light indicators in UI
                updateLightIndicators();

                // Update outdoor lamppost if there are outdoor lights
                if (roomLights['Outdoor'].length > 0) {
                    const outdoorLightOn = roomLights['Outdoor'].some(light => light.on);
                    updateOutdoorLamppost(outdoorLightOn);
                } else {
                    // If no outdoor light detected, turn it off
                    updateOutdoorLamppost(false);
                }

            } catch (error) {
                console.error('Error loading lights:', error);
            }
        }

        function mapMotionSensorToRoom(sensorName) {
            const nameLower = sensorName.toLowerCase();

            if (nameLower.includes('outdoor') || nameLower.includes('outside') || nameLower.includes('garden')) return 'Outdoor';
            if (nameLower.includes('hall') || nameLower.includes('frontdoor') || nameLower.includes('front door')) return 'Hall';
            if (nameLower.includes('landing')) return 'Landing';
            if (nameLower.includes('bathroom') || nameLower.includes('bath')) return 'Bathroom';

            return null;
        }

        async function loadSensorDetails() {
            try {
                const response = await fetch(`http://${BRIDGE_IP}/api/${USERNAME}/sensors`);
                if (!response.ok) return;

                const sensors = await response.json();
                const container = document.getElementById('sensor-details');
                if (!container) return;

                // Group sensors by their physical device (based on uniqueid prefix)
                const sensorGroups = {};

                for (const [sensorId, sensorInfo] of Object.entries(sensors)) {
                    // Extract base name (remove "motion sensor", "temperature", etc.)
                    let baseName = sensorInfo.name
                        .replace(/temperature sensor/i, '')
                        .replace(/motion sensor/i, '')
                        .replace(/ambient light sensor/i, '')
                        .replace(/\d+$/i, '') // Remove trailing numbers
                        .trim();

                    if (!baseName) baseName = sensorInfo.name;

                    if (!sensorGroups[baseName]) {
                        sensorGroups[baseName] = {
                            name: baseName,
                            temperature: null,
                            lightLevel: null,
                            motion: null,
                            battery: null
                        };
                    }

                    // Collect data based on sensor type
                    if (sensorInfo.type === 'ZLLTemperature' && sensorInfo.state.temperature !== null) {
                        sensorGroups[baseName].temperature = (sensorInfo.state.temperature / 100).toFixed(1);
                    }
                    if (sensorInfo.type === 'ZLLLightLevel' && sensorInfo.state.lightlevel !== null) {
                        sensorGroups[baseName].lightLevel = sensorInfo.state.lightlevel;
                        sensorGroups[baseName].lux = sensorInfo.state.daylight ? 'Daylight' : sensorInfo.state.dark ? 'Dark' : 'Dim';
                    }
                    if (sensorInfo.type === 'ZLLPresence') {
                        sensorGroups[baseName].motion = sensorInfo.state.presence;
                    }
                    if (sensorInfo.config && sensorInfo.config.battery !== undefined) {
                        sensorGroups[baseName].battery = sensorInfo.config.battery;
                    }
                }

                // Build HTML for sensor cards
                let html = '';
                for (const [key, sensor] of Object.entries(sensorGroups)) {
                    // Only show sensors that have at least one data point
                    if (!sensor.temperature && sensor.lightLevel === null && sensor.motion === null && sensor.battery === null) {
                        continue;
                    }

                    const roomEmoji = {
                        'Landing': 'ü™ú',
                        'Main Bedroom': 'üõèÔ∏è',
                        'Guest Room': 'üõèÔ∏è',
                        'Hue temperature sensor': 'üè¢',
                        'Bathroom': 'üöø',
                        'Hall': 'üö™',
                        'Lounge': 'üõãÔ∏è',
                        'ExtensionDimmer': 'üè†',
                        'KitchenSensor': 'üç≥',
                        'Hue outdoor temp. sensor': 'üå≥'
                    };
                    const emoji = roomEmoji[sensor.name] || 'üìç';

                    // Battery color based on level
                    let batteryColor = '#4CAF50'; // Green
                    if (sensor.battery !== null) {
                        if (sensor.battery < 20) batteryColor = '#f44336'; // Red
                        else if (sensor.battery < 50) batteryColor = '#FF9800'; // Orange
                    }

                    // Light level emoji
                    let lightEmoji = '‚òÄÔ∏è';
                    if (sensor.lux === 'Dark') lightEmoji = 'üåô';
                    else if (sensor.lux === 'Dim') lightEmoji = 'üå§Ô∏è';

                    html += `<div style="background: linear-gradient(135deg, #ffffff 0%, #f5f5f5 100%); padding: 15px; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); border: 2px solid #e0e0e0;">`;
                    html += `<div style="font-weight: 700; font-size: 16px; margin-bottom: 12px; color: #333; font-family: 'Fredoka', sans-serif;">${emoji} ${sensor.name}</div>`;

                    // Temperature
                    if (sensor.temperature) {
                        const tempColor = getTemperatureColor(parseFloat(sensor.temperature));
                        html += `<div style="display: flex; align-items: center; margin-bottom: 8px; padding: 6px; background: white; border-radius: 8px;">`;
                        html += `<span style="font-size: 20px; margin-right: 8px;">üå°Ô∏è</span>`;
                        html += `<span style="flex: 1; font-weight: 600;">Temperature</span>`;
                        html += `<span style="font-weight: 700; color: ${tempColor}; font-size: 18px;">${sensor.temperature}¬∞C</span>`;
                        html += `</div>`;
                    }

                    // Light Level
                    if (sensor.lightLevel !== null) {
                        html += `<div style="display: flex; align-items: center; margin-bottom: 8px; padding: 6px; background: white; border-radius: 8px;">`;
                        html += `<span style="font-size: 20px; margin-right: 8px;">${lightEmoji}</span>`;
                        html += `<span style="flex: 1; font-weight: 600;">Light Level</span>`;
                        html += `<span style="font-weight: 700; color: #FFA500;">${sensor.lux} (${sensor.lightLevel})</span>`;
                        html += `</div>`;
                    }

                    // Motion
                    if (sensor.motion !== null) {
                        const motionColor = sensor.motion ? '#f44336' : '#4CAF50';
                        const motionText = sensor.motion ? 'üö∂ DETECTED' : '‚úÖ Clear';
                        html += `<div style="display: flex; align-items: center; margin-bottom: 8px; padding: 6px; background: white; border-radius: 8px;">`;
                        html += `<span style="flex: 1; font-weight: 600;">Motion</span>`;
                        html += `<span style="font-weight: 700; color: ${motionColor};">${motionText}</span>`;
                        html += `</div>`;
                    }

                    // Battery
                    if (sensor.battery !== null) {
                        let batteryIcon = 'üîã';
                        if (sensor.battery < 20) batteryIcon = 'ü™´';
                        html += `<div style="display: flex; align-items: center; padding: 6px; background: white; border-radius: 8px;">`;
                        html += `<span style="font-size: 20px; margin-right: 8px;">${batteryIcon}</span>`;
                        html += `<span style="flex: 1; font-weight: 600;">Battery</span>`;
                        html += `<span style="font-weight: 700; color: ${batteryColor};">${sensor.battery}%</span>`;
                        html += `</div>`;
                    }

                    html += `</div>`;
                }

                container.innerHTML = html || '<div style="text-align: center; color: #999; padding: 20px;">No sensor data available</div>';

            } catch (error) {
                console.error('Error loading sensor details:', error);
            }
        }

        async function loadMotionSensors() {
            try {
                const response = await fetch(`http://${BRIDGE_IP}/api/${USERNAME}/sensors`);
                if (!response.ok) return;

                const sensors = await response.json();

                // Debug: log all motion sensors found
                console.log('=== Motion Sensors Scan ===');

                // Process motion sensors
                for (const [sensorId, sensorInfo] of Object.entries(sensors)) {
                    if (sensorInfo.type === 'ZLLPresence') {
                        const room = mapMotionSensorToRoom(sensorInfo.name);

                        // Debug logging
                        console.log(`Sensor: "${sensorInfo.name}" | Presence: ${sensorInfo.state.presence} | Mapped to: ${room || 'UNMAPPED'}`);

                        if (room && motionSensors[room]) {
                            // Store previous state
                            motionSensors[room].previousDetected = motionSensors[room].detected;

                            // Update current state
                            motionSensors[room].detected = sensorInfo.state.presence;
                            motionSensors[room].lastUpdated = sensorInfo.state.lastupdated;

                            // Check if motion just started (changed from false to true)
                            if (motionSensors[room].detected && !motionSensors[room].previousDetected) {
                                console.log(`üîä ANNOUNCING: Motion in ${room}`);
                                announceMotion(room);
                                logMotionEvent(room); // Log the event
                            }
                        }
                    }
                }

                // Update motion indicators in UI
                updateMotionIndicators();

            } catch (error) {
                console.error('Error loading motion sensors:', error);
            }
        }

        function updateMotionIndicators() {
            const positions = {
                'Outdoor': { x: 155, y: 100, isOutdoor: true },
                'Hall': { x: 200, y: 420 },
                'Landing': { x: 340, y: 250 },
                'Bathroom': { x: 660, y: 250 }
            };

            const container = document.getElementById('motion-indicators-container');
            if (!container) return;

            // Clear both indoor and outdoor motion indicators
            container.innerHTML = '';

            // Clear outdoor motion indicators (they're in the outdoor-area container)
            const outdoorArea = document.querySelector('#outdoor-area');
            if (outdoorArea) {
                // Remove any existing motion indicator groups from outdoor area
                const outdoorMotionIndicators = outdoorArea.querySelectorAll('.motion-indicator');
                outdoorMotionIndicators.forEach(el => el.remove());
            }

            const ns = 'http://www.w3.org/2000/svg';

            for (const [room, motion] of Object.entries(motionSensors)) {
                if (!motion.detected) continue; // Only show when motion detected

                const pos = positions[room];
                if (!pos) continue;

                // Create motion indicator group
                const group = document.createElementNS(ns, 'g');
                group.setAttribute('class', 'motion-indicator'); // Add class for easy cleanup

                if (pos.isOutdoor) {
                    // Position relative to outdoor area
                    group.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);
                } else {
                    group.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);
                }

                // Monkey face icon
                const monkeyGroup = document.createElementNS(ns, 'g');
                monkeyGroup.setAttribute('class', 'monkey-shake');

                // Monkey head (brown circle)
                const head = document.createElementNS(ns, 'circle');
                head.setAttribute('cx', '0');
                head.setAttribute('cy', '0');
                head.setAttribute('r', '18');
                head.setAttribute('fill', '#8B4513');
                head.setAttribute('stroke', '#5D2E0F');
                head.setAttribute('stroke-width', '2');
                monkeyGroup.appendChild(head);

                // Face area (lighter brown)
                const face = document.createElementNS(ns, 'ellipse');
                face.setAttribute('cx', '0');
                face.setAttribute('cy', '3');
                face.setAttribute('rx', '12');
                face.setAttribute('ry', '10');
                face.setAttribute('fill', '#D2691E');
                monkeyGroup.appendChild(face);

                // Left ear
                const leftEar = document.createElementNS(ns, 'circle');
                leftEar.setAttribute('cx', '-15');
                leftEar.setAttribute('cy', '-8');
                leftEar.setAttribute('r', '6');
                leftEar.setAttribute('fill', '#8B4513');
                leftEar.setAttribute('stroke', '#5D2E0F');
                leftEar.setAttribute('stroke-width', '1.5');
                monkeyGroup.appendChild(leftEar);

                // Right ear
                const rightEar = document.createElementNS(ns, 'circle');
                rightEar.setAttribute('cx', '15');
                rightEar.setAttribute('cy', '-8');
                rightEar.setAttribute('r', '6');
                rightEar.setAttribute('fill', '#8B4513');
                rightEar.setAttribute('stroke', '#5D2E0F');
                rightEar.setAttribute('stroke-width', '1.5');
                monkeyGroup.appendChild(rightEar);

                // Left eye
                const leftEye = document.createElementNS(ns, 'circle');
                leftEye.setAttribute('cx', '-6');
                leftEye.setAttribute('cy', '-2');
                leftEye.setAttribute('r', '3');
                leftEye.setAttribute('fill', 'white');
                monkeyGroup.appendChild(leftEye);

                const leftPupil = document.createElementNS(ns, 'circle');
                leftPupil.setAttribute('cx', '-5');
                leftPupil.setAttribute('cy', '-1');
                leftPupil.setAttribute('r', '2');
                leftPupil.setAttribute('fill', 'black');
                monkeyGroup.appendChild(leftPupil);

                // Right eye
                const rightEye = document.createElementNS(ns, 'circle');
                rightEye.setAttribute('cx', '6');
                rightEye.setAttribute('cy', '-2');
                rightEye.setAttribute('r', '3');
                rightEye.setAttribute('fill', 'white');
                monkeyGroup.appendChild(rightEye);

                const rightPupil = document.createElementNS(ns, 'circle');
                rightPupil.setAttribute('cx', '7');
                rightPupil.setAttribute('cy', '-1');
                rightPupil.setAttribute('r', '2');
                rightPupil.setAttribute('fill', 'black');
                monkeyGroup.appendChild(rightPupil);

                // Nose
                const nose = document.createElementNS(ns, 'ellipse');
                nose.setAttribute('cx', '0');
                nose.setAttribute('cy', '5');
                nose.setAttribute('rx', '3');
                nose.setAttribute('ry', '2');
                nose.setAttribute('fill', '#5D2E0F');
                monkeyGroup.appendChild(nose);

                // Mouth (smile)
                const mouth = document.createElementNS(ns, 'path');
                mouth.setAttribute('d', 'M -5 8 Q 0 12 5 8');
                mouth.setAttribute('stroke', '#5D2E0F');
                mouth.setAttribute('stroke-width', '1.5');
                mouth.setAttribute('fill', 'none');
                mouth.setAttribute('stroke-linecap', 'round');
                monkeyGroup.appendChild(mouth);

                group.appendChild(monkeyGroup);

                // Schedule fade-out after 30 seconds
                setTimeout(() => {
                    monkeyGroup.setAttribute('class', 'monkey-shake monkey-fadeout');
                    // Remove the element after fade completes
                    setTimeout(() => {
                        group.remove();
                    }, 2000);
                }, 30000);

                // Pulsing circle around person
                const pulseCircle = document.createElementNS(ns, 'circle');
                pulseCircle.setAttribute('cx', '0');
                pulseCircle.setAttribute('cy', '0');
                pulseCircle.setAttribute('r', '15');
                pulseCircle.setAttribute('fill', 'none');
                pulseCircle.setAttribute('stroke', '#FF6B6B');
                pulseCircle.setAttribute('stroke-width', '2');
                pulseCircle.setAttribute('opacity', '0.6');
                pulseCircle.setAttribute('class', 'motion-pulse');
                group.appendChild(pulseCircle);

                // Motion text label
                const label = document.createElementNS(ns, 'text');
                label.setAttribute('x', '0');
                label.setAttribute('y', '35');
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('font-size', '12');
                label.setAttribute('font-weight', '700');
                label.setAttribute('font-family', 'Fredoka');
                label.setAttribute('fill', '#5D2E0F');
                label.textContent = 'OOH OOH!';
                group.appendChild(label);

                if (pos.isOutdoor) {
                    document.querySelector('#outdoor-area').appendChild(group);
                } else {
                    container.appendChild(group);
                }
            }
        }

        function updateLightIndicators() {
            const roomPositionsForLights = {
                'Main Bedroom': { x: 180, y: 240 },
                'Landing': { x: 340, y: 240 },
                'Home Office': { x: 500, y: 240 },
                'Bathroom': { x: 660, y: 240 },
                'Guest Bedroom': { x: 820, y: 240 },
                'Hall': { x: 200, y: 405 },
                'Lounge': { x: 400, y: 405 },
                'Kitchen': { x: 600, y: 405 },
                'Extension': { x: 800, y: 405 }
            };

            const container = document.getElementById('light-indicators-container');
            if (!container) return;

            container.innerHTML = '';

            const ns = 'http://www.w3.org/2000/svg';

            for (const [room, lights] of Object.entries(roomLights)) {
                if (lights.length === 0) continue;

                const pos = roomPositionsForLights[room];
                if (!pos) continue;

                // Create a group for this room's lights
                const group = document.createElementNS(ns, 'g');

                lights.forEach((light, index) => {
                    const offsetX = (index - (lights.length - 1) / 2) * 20;

                    // Light bulb icon
                    const bulb = document.createElementNS(ns, 'circle');
                    bulb.setAttribute('cx', pos.x + offsetX);
                    bulb.setAttribute('cy', pos.y);
                    bulb.setAttribute('r', 6);
                    bulb.setAttribute('fill', light.on ? '#FFD700' : '#666');
                    bulb.setAttribute('stroke', light.on ? '#FFA500' : '#333');
                    bulb.setAttribute('stroke-width', '1.5');
                    bulb.setAttribute('class', 'light-indicator');
                    bulb.style.cursor = 'pointer';

                    if (light.on) {
                        bulb.setAttribute('filter', 'url(#glow)');
                    }

                    // Tooltip
                    const title = document.createElementNS(ns, 'title');
                    title.textContent = `${light.name}: ${light.on ? 'ON' : 'OFF'} (double-click to toggle)`;
                    bulb.appendChild(title);

                    // Double-click to toggle light
                    bulb.addEventListener('dblclick', () => {
                        toggleLight(light.id, light.on);
                    });

                    group.appendChild(bulb);
                });

                container.appendChild(group);
            }
        }

        async function loadTemperatures(showSparkles = true) {
            const btn = document.getElementById('refreshBtn');
            if (showSparkles) btn.classList.add('loading');

            try {
                const response = await fetch(`http://${BRIDGE_IP}/api/${USERNAME}/sensors`);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const sensors = await response.json();
                const temps = [];

                // Clear existing thermometers
                document.getElementById('thermometers-container').innerHTML = '';
                document.getElementById('outdoor-thermometer-container').innerHTML = '';

                for (const [sensorId, sensorInfo] of Object.entries(sensors)) {
                    if (sensorInfo.type === 'ZLLTemperature') {
                        const name = sensorInfo.name;
                        const elementId = sensorMapping[name];

                        if (elementId) {
                            const temp = sensorInfo.state.temperature;

                            if (temp !== null && temp !== undefined) {
                                const tempC = (temp / 100.0).toFixed(1);
                                const roomName = roomNames[name] || name;

                                // Create thermometer for this room
                                const tempElement = createThermometer(elementId, parseFloat(tempC), roomName);

                                // Save temperature data for graphing
                                saveTempData(name, tempC);

                                // Create sparkles on update!
                                if (tempElement && showSparkles) {
                                    setTimeout(() => createSparkles(tempElement), 100);
                                }

                                // Only add to stats if not outdoor
                                if (name !== 'Hue outdoor temp. sensor 1') {
                                    temps.push(parseFloat(tempC));
                                }
                            }
                            // If temp is null/undefined, we simply don't create a thermometer (nothing displayed)
                        }
                    }
                }

                // Calculate statistics
                if (temps.length > 0) {
                    const avg = (temps.reduce((a, b) => a + b, 0) / temps.length).toFixed(1);
                    const max = Math.max(...temps).toFixed(1);
                    const min = Math.min(...temps).toFixed(1);
                    const range = (max - min).toFixed(1);

                    const avgEl = document.getElementById('avg-temp');
                    const maxEl = document.getElementById('max-temp');
                    const minEl = document.getElementById('min-temp');
                    const rangeEl = document.getElementById('range-temp');

                    avgEl.textContent = avg + '¬∞C';
                    maxEl.textContent = max + '¬∞C';
                    minEl.textContent = min + '¬∞C';
                    rangeEl.textContent = range + '¬∞C';

                    // Add sparkles to stats cards
                    if (showSparkles) {
                        setTimeout(() => createSparkles(avgEl), 100);
                        setTimeout(() => createSparkles(maxEl), 200);
                        setTimeout(() => createSparkles(minEl), 300);
                        setTimeout(() => createSparkles(rangeEl), 400);
                    }
                }

                const now = new Date();
                document.getElementById('lastUpdate').textContent =
                    `Last updated: ${now.toLocaleString()} ‚ú®`;

                // Redraw graph with new data
                drawGraph();

            } catch (error) {
                console.error('Error loading temperatures:', error);
                document.getElementById('lastUpdate').textContent =
                    `‚ö†Ô∏è Oops! ${error.message}`;
            } finally {
                if (showSparkles) btn.classList.remove('loading');
            }
        }

        // Diagnostic: Show all lights
        async function showAllLights() {
            try {
                const response = await fetch(`http://${BRIDGE_IP}/api/${USERNAME}/lights`);
                const lights = await response.json();

                console.log('\n');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('                    ALL HUE LIGHTS                         ');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('\n');

                for (const [id, light] of Object.entries(lights)) {
                    const room = mapLightToRoom(light.name);
                    console.log(`‚îå‚îÄ Light ID: ${id} ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
                    console.log(`‚îÇ Name: "${light.name}"`);
                    console.log(`‚îÇ Type: ${light.type}`);
                    console.log(`‚îÇ Model: ${light.modelid || 'N/A'}`);
                    console.log(`‚îÇ State: ${light.state.on ? 'ON' : 'OFF'}`);
                    console.log(`‚îÇ Reachable: ${light.state.reachable}`);
                    console.log(`‚îÇ Mapped to room: ${room || '‚ùå NOT MAPPED'}`);
                    console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                    console.log('\n');
                }

                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log(`Total lights found: ${Object.keys(lights).length}`);
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('\n');

            } catch (error) {
                console.error('Error fetching lights:', error);
            }
        }

        // Diagnostic: Show all sensors
        async function showAllSensors() {
            try {
                const response = await fetch(`http://${BRIDGE_IP}/api/${USERNAME}/sensors`);
                const sensors = await response.json();

                console.log('\n');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('                    ALL HUE SENSORS                        ');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('\n');

                for (const [id, sensor] of Object.entries(sensors)) {
                    console.log(`‚îå‚îÄ Sensor ID: ${id} ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
                    console.log(`‚îÇ Name: "${sensor.name}"`);
                    console.log(`‚îÇ Type: ${sensor.type}`);
                    console.log(`‚îÇ Model: ${sensor.modelid || 'N/A'}`);
                    console.log(`‚îÇ Manufacturer: ${sensor.manufacturername || 'N/A'}`);

                    if (sensor.state) {
                        console.log(`‚îÇ State:`);
                        for (const [key, value] of Object.entries(sensor.state)) {
                            console.log(`‚îÇ   - ${key}: ${value}`);
                        }
                    }

                    console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                    console.log('\n');
                }

                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log(`Total sensors found: ${Object.keys(sensors).length}`);
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('\n');

            } catch (error) {
                console.error('Error fetching sensors:', error);
            }
        }

        // Initialize temperature history
        initTempHistory();

        // Initialize motion detection history
        initMotionHistory();

        // Toggle collapsible sections
        function toggleSection(contentId, arrowId) {
            const content = document.getElementById(contentId);
            const arrow = document.getElementById(arrowId);

            if (content && arrow) {
                content.classList.toggle('collapsed');
                arrow.classList.toggle('collapsed');
            }
        }

        // Chelmsford, Essex, UK coordinates
        const CHELMSFORD_LAT = 51.7356;
        const CHELMSFORD_LNG = 0.4685;

        // Store sunrise/sunset times
        let sunriseTime = null;
        let sunsetTime = null;

        // Fetch sunrise/sunset times for Chelmsford
        async function fetchSunTimes() {
            try {
                const response = await fetch(`https://api.sunrise-sunset.org/json?lat=${CHELMSFORD_LAT}&lng=${CHELMSFORD_LNG}&formatted=0`);
                const data = await response.json();

                if (data.status === 'OK') {
                    sunriseTime = new Date(data.results.sunrise);
                    sunsetTime = new Date(data.results.sunset);

                    console.log(`üåÖ Sunrise today: ${sunriseTime.toLocaleTimeString()}`);
                    console.log(`üåá Sunset today: ${sunsetTime.toLocaleTimeString()}`);

                    // Update sky immediately with new times
                    updateSky();
                }
            } catch (error) {
                console.error('Error fetching sun times:', error);
                // Fallback to default times if API fails
                const now = new Date();
                sunriseTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 7, 0);
                sunsetTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 17, 0);
            }
        }

        // Fetch weather data from WeatherAPI.com
        async function fetchWeather() {
            if (!WEATHER_CONFIG?.API_KEY || WEATHER_CONFIG.API_KEY === 'YOUR-WEATHERAPI-KEY-HERE') {
                console.warn('‚ö†Ô∏è Weather API key not configured');
                return null;
            }

            try {
                const response = await fetch(
                    `https://api.weatherapi.com/v1/current.json?key=${WEATHER_CONFIG.API_KEY}&q=${WEATHER_CONFIG.LOCATION}`
                );

                if (!response.ok) {
                    throw new Error(`Weather API error: ${response.status}`);
                }

                const data = await response.json();

                return {
                    temp: data.current.temp_c,
                    condition: data.current.condition.text,
                    icon: data.current.condition.icon,
                    humidity: data.current.humidity,
                    feelsLike: data.current.feelslike_c,
                    uv: data.current.uv,
                    wind: data.current.wind_kph,
                    windDir: data.current.wind_dir
                };
            } catch (error) {
                console.error('Error fetching weather:', error);
                return null;
            }
        }

        // Update weather display
        async function updateWeatherDisplay() {
            const weatherData = await fetchWeather();

            if (!weatherData) {
                return;
            }

            // Update weather stat card
            const weatherTempEl = document.getElementById('weather-temp');
            const weatherConditionEl = document.getElementById('weather-condition');
            const weatherIconEl = document.getElementById('weather-icon');
            const weatherFeelsEl = document.getElementById('weather-feels');
            const weatherHumidityEl = document.getElementById('weather-humidity');
            const weatherUvEl = document.getElementById('weather-uv');

            if (weatherTempEl) weatherTempEl.textContent = `${weatherData.temp.toFixed(1)}¬∞C`;
            if (weatherConditionEl) weatherConditionEl.textContent = weatherData.condition;
            if (weatherIconEl) weatherIconEl.src = `https:${weatherData.icon}`;
            if (weatherFeelsEl) weatherFeelsEl.textContent = `Feels like ${weatherData.feelsLike.toFixed(1)}¬∞C`;
            if (weatherHumidityEl) weatherHumidityEl.textContent = `üíß ${weatherData.humidity}%`;
            if (weatherUvEl) weatherUvEl.textContent = `‚òÄÔ∏è UV ${weatherData.uv}`;

            console.log(`üå§Ô∏è Weather updated: ${weatherData.temp.toFixed(1)}¬∞C, ${weatherData.condition}`);

            // Update visual effects based on weather
            updateWeatherVisuals(weatherData);
        }

        // Update visual effects based on weather conditions
        function updateWeatherVisuals(weatherData) {
            if (!weatherData) return;

            const rainEl = document.getElementById('rain');
            const snowEl = document.getElementById('snow');
            const fogEl = document.getElementById('fog');
            const skyGradient = document.getElementById('skyGradient');

            // Hide all weather effects by default
            if (rainEl) rainEl.style.display = 'none';
            if (snowEl) snowEl.style.display = 'none';
            if (fogEl) fogEl.style.display = 'none';

            const condition = weatherData.condition.toLowerCase();
            const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;

            // Determine weather effects and sky colors
            let skyColor1, skyColor2;

            if (condition.includes('rain') || condition.includes('drizzle') || condition.includes('shower')) {
                // Show rain
                if (rainEl) rainEl.style.display = 'block';
                skyColor1 = '#6B7F8F';
                skyColor2 = '#8B9DAF';
                console.log('üåßÔ∏è Rain effect activated');
            } else if (condition.includes('snow') || condition.includes('sleet') || condition.includes('blizzard')) {
                // Show snow
                if (snowEl) snowEl.style.display = 'block';
                skyColor1 = '#D0D8E0';
                skyColor2 = '#E8EEF5';
                console.log('‚ùÑÔ∏è Snow effect activated');
            } else if (condition.includes('fog') || condition.includes('mist') || condition.includes('haze')) {
                // Show fog
                if (fogEl) fogEl.style.display = 'block';
                skyColor1 = '#B0B8C0';
                skyColor2 = '#D0D8E0';
                console.log('üå´Ô∏è Fog effect activated');
            } else if (condition.includes('thunder') || condition.includes('storm')) {
                // Stormy - darker sky, show rain
                if (rainEl) rainEl.style.display = 'block';
                skyColor1 = '#4A5568';
                skyColor2 = '#6B7F8F';
                console.log('‚õàÔ∏è Storm effect activated');
            } else if (condition.includes('cloud') || condition.includes('overcast')) {
                // Cloudy
                skyColor1 = '#A0AEC0';
                skyColor2 = '#C0CED8';
                console.log('‚òÅÔ∏è Cloudy sky');
            } else if (condition.includes('clear') || condition.includes('sunny')) {
                // Clear/Sunny - use default bright colors
                skyColor1 = '#87CEEB';
                skyColor2 = '#E0F6FF';
                console.log('‚òÄÔ∏è Clear sky');
            } else {
                // Partly cloudy or other
                skyColor1 = '#98C8E8';
                skyColor2 = '#D0E8F8';
            }

            // Don't override sky colors in dark mode
            if (!isDarkMode && skyGradient) {
                const stops = skyGradient.getElementsByTagName('stop');
                if (stops.length >= 2) {
                    stops[0].setAttribute('style', `stop-color:${skyColor1};stop-opacity:0.3`);
                    stops[1].setAttribute('style', `stop-color:${skyColor2};stop-opacity:0.1`);
                }
            }

            // Adjust cloud opacity based on weather
            const cloudOpacity = condition.includes('cloud') || condition.includes('overcast') ? 0.9 : 0.7;
            const cloudColor = condition.includes('rain') || condition.includes('storm') ? '#808080' :
                              (condition.includes('fog') || condition.includes('mist') ? '#B0B0B0' : 'white');

            // Update CSS variable for clouds if not in dark mode
            if (!isDarkMode) {
                document.documentElement.style.setProperty('--cloud-color', cloudColor);
                document.documentElement.style.setProperty('--cloud-opacity', cloudOpacity);
            }
        }

        // Update sky based on time of day (using actual sunrise/sunset)
        function updateSky() {
            const now = new Date();

            const skyGradient = document.getElementById('skyGradient');
            const sun = document.getElementById('sun');
            const moon = document.getElementById('moon');
            const stars = document.getElementById('stars');

            if (!skyGradient) return;

            // Check for dark mode - override time-based sky if dark mode is active
            const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;

            if (isDarkMode) {
                // Force night theme in dark mode
                const skyConfig = {
                    color1: '#0B1026', // Dark blue/black
                    color2: '#1E3A5F', // Deep blue
                    showSun: false,
                    showMoon: true,
                    showStars: true
                };

                // Update sky gradient
                const stops = skyGradient.getElementsByTagName('stop');
                if (stops.length >= 2) {
                    stops[0].setAttribute('style', `stop-color:${skyConfig.color1};stop-opacity:1`);
                    stops[1].setAttribute('style', `stop-color:${skyConfig.color2};stop-opacity:1`);
                }

                // Show/hide sun, moon, and stars
                if (sun) sun.style.display = 'none';
                if (moon) moon.style.display = 'block';
                if (stars) stars.style.display = 'block';
                return;
            }

            // If we don't have sun times yet, use defaults
            if (!sunriseTime || !sunsetTime) {
                sunriseTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 7, 0);
                sunsetTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 17, 0);
            }

            // Calculate time periods based on actual sunrise/sunset
            const dawnStart = new Date(sunriseTime.getTime() - 60 * 60 * 1000); // 1 hour before sunrise
            const dawnEnd = sunriseTime;
            const duskStart = sunsetTime;
            const duskEnd = new Date(sunsetTime.getTime() + 90 * 60 * 1000); // 1.5 hours after sunset

            let skyConfig;

            // Determine sky configuration based on actual sun times
            if (now >= dawnStart && now < dawnEnd) {
                // Dawn (1 hour before sunrise)
                skyConfig = {
                    color1: '#FF6B6B', // Pink
                    color2: '#FFD93D', // Golden yellow
                    showSun: true,
                    showMoon: false,
                    showStars: false
                };
            } else if (now >= dawnEnd && now < duskStart) {
                // Day (sunrise to sunset)
                skyConfig = {
                    color1: '#87CEEB', // Sky blue
                    color2: '#E0F6FF', // Very light blue
                    showSun: true,
                    showMoon: false,
                    showStars: false
                };
            } else if (now >= duskStart && now < duskEnd) {
                // Dusk (sunset to 1.5 hours after)
                skyConfig = {
                    color1: '#FF6B35', // Orange
                    color2: '#6A4C93', // Purple
                    showSun: true,
                    showMoon: false,
                    showStars: true
                };
            } else {
                // Night (rest of the time)
                skyConfig = {
                    color1: '#0B1026', // Dark blue/black
                    color2: '#1E3A5F', // Deep blue
                    showSun: false,
                    showMoon: true,
                    showStars: true
                };
            }

            // Update sky gradient
            const stops = skyGradient.getElementsByTagName('stop');
            if (stops.length >= 2) {
                stops[0].setAttribute('style', `stop-color:${skyConfig.color1};stop-opacity:1`);
                stops[1].setAttribute('style', `stop-color:${skyConfig.color2};stop-opacity:1`);
            }

            // Show/hide sun, moon, and stars
            if (sun) sun.style.display = skyConfig.showSun ? 'block' : 'none';
            if (moon) moon.style.display = skyConfig.showMoon ? 'block' : 'none';
            if (stars) stars.style.display = skyConfig.showStars ? 'block' : 'none';
        }

        // Setup outdoor lamppost double-click handler
        function setupLampostClickHandler() {
            const lampHousing = document.getElementById('lamp-housing');
            if (lampHousing) {
                lampHousing.addEventListener('dblclick', () => {
                    // Find the outdoor light
                    if (roomLights['Outdoor'] && roomLights['Outdoor'].length > 0) {
                        const outdoorLight = roomLights['Outdoor'][0];
                        toggleLight(outdoorLight.id, outdoorLight.on);
                    }
                });
            }
        }

        // Show all sensors and lights for debugging
        showAllSensors();
        showAllLights();

        // Fetch sunrise/sunset times for Chelmsford and update sky
        fetchSunTimes();

        // Load all data on page load
        loadTemperatures();
        loadLights().then(() => {
            // Setup lamppost click handler after lights are loaded
            setupLampostClickHandler();
        });
        loadMotionSensors();
        loadSensorDetails();
        updateWeatherDisplay();

        // Real-time polling with different intervals for different data types
        // Motion sensors: every 3 seconds (critical for real-time detection)
        setInterval(loadMotionSensors, 3000);

        // Lights: every 10 seconds (change frequently)
        setInterval(loadLights, 10000);

        // Sensor details: every 10 seconds (includes light levels, battery, motion)
        setInterval(loadSensorDetails, 10000);

        // Temperatures: every 60 seconds (change slowly, without sparkles to reduce visual noise)
        setInterval(() => loadTemperatures(false), 60000);

        // Update motion log display every minute to refresh "time ago"
        setInterval(updateMotionLogDisplay, 60000);

        // Update sky every minute to check for time of day changes
        setInterval(updateSky, 60000);

        // Refresh sunrise/sunset times once per day (every 24 hours)
        setInterval(fetchSunTimes, 24 * 60 * 60 * 1000);

        // Weather: every 15 minutes (API rate limit friendly)
        setInterval(updateWeatherDisplay, (WEATHER_CONFIG?.UPDATE_INTERVAL || 15) * 60 * 1000);

        // ============================================================================
        // FUN LIGHT EFFECTS
        // ============================================================================

        let originalLightStates = {};
        let effectInProgress = false;

        // Helper: Get all lights with their current state
        async function getAllLights() {
            try {
                const response = await fetch(`http://${BRIDGE_IP}/api/${USERNAME}/lights`);
                if (!response.ok) return null;
                return await response.json();
            } catch (error) {
                console.error('Error getting lights:', error);
                return null;
            }
        }

        // Helper: Set a light to specific state
        async function setLightState(lightId, state) {
            try {
                await fetch(`http://${BRIDGE_IP}/api/${USERNAME}/lights/${lightId}/state`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(state)
                });
            } catch (error) {
                console.error(`Error setting light ${lightId}:`, error);
            }
        }

        // Helper: Save current state of all lights
        async function saveLightStates() {
            const lights = await getAllLights();
            if (!lights) return false;

            originalLightStates = {};
            for (const [lightId, light] of Object.entries(lights)) {
                originalLightStates[lightId] = {
                    on: light.state.on,
                    bri: light.state.bri,
                    hue: light.state.hue,
                    sat: light.state.sat
                };
            }
            return true;
        }

        // Helper: Restore original light states
        async function restoreLightStates() {
            for (const [lightId, state] of Object.entries(originalLightStates)) {
                await setLightState(lightId, state);
                await new Promise(resolve => setTimeout(resolve, 50)); // Small delay between commands
            }
            setTimeout(loadLights, 500); // Refresh UI
            effectInProgress = false;
        }

        // Helper: Disable all effect buttons
        function disableEffectButtons(disable) {
            const buttons = ['redAlertBtn', 'partyBtn', 'discoBtn', 'waveBtn', 'sunsetBtn'];
            buttons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) btn.disabled = disable;
            });
        }

        // Helper: Confirm light effect with time-based warning
        function confirmEffect(effectName) {
            const hour = new Date().getHours();
            const isNightTime = hour >= 22 || hour < 7; // 10pm to 7am

            let message = `Run ${effectName} effect?\n\nThis will change all lights in your home.`;

            if (isNightTime) {
                message += `\n\n‚ö†Ô∏è WARNING: It's currently ${hour}:00 - people may be sleeping!`;
            }

            return confirm(message);
        }

        // üö® RED ALERT - Flash all lights red
        async function redAlert() {
            if (!confirmEffect('Red Alert')) return;
            if (effectInProgress) return;
            effectInProgress = true;
            disableEffectButtons(true);

            const success = await saveLightStates();
            if (!success) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            const lights = await getAllLights();
            if (!lights) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            // Flash red 6 times (3 seconds total)
            for (let i = 0; i < 6; i++) {
                // Turn all lights red and bright
                for (const lightId of Object.keys(lights)) {
                    await setLightState(lightId, {
                        on: true,
                        bri: 254,
                        hue: 0, // Red
                        sat: 254,
                        transitiontime: 0 // Instant
                    });
                }

                await new Promise(resolve => setTimeout(resolve, 250));

                // Turn all lights off briefly
                for (const lightId of Object.keys(lights)) {
                    await setLightState(lightId, { on: false, transitiontime: 0 });
                }

                await new Promise(resolve => setTimeout(resolve, 250));
            }

            // Restore original states
            await restoreLightStates();
            disableEffectButtons(false);
        }

        // üéâ PARTY MODE - Cycle through rainbow colors
        async function partyMode() {
            if (!confirmEffect('Party Mode')) return;
            if (effectInProgress) return;
            effectInProgress = true;
            disableEffectButtons(true);

            const success = await saveLightStates();
            if (!success) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            const lights = await getAllLights();
            if (!lights) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            // Rainbow colors (hue values in Philips Hue scale: 0-65535)
            const colors = [
                0,      // Red
                10922,  // Orange
                12750,  // Yellow
                25500,  // Green
                46920,  // Blue
                56100   // Purple
            ];

            // Cycle through colors for 6 seconds
            for (let cycle = 0; cycle < 12; cycle++) {
                const hue = colors[cycle % colors.length];

                for (const lightId of Object.keys(lights)) {
                    await setLightState(lightId, {
                        on: true,
                        bri: 254,
                        hue: hue,
                        sat: 254,
                        transitiontime: 5 // Smooth transition
                    });
                }

                await new Promise(resolve => setTimeout(resolve, 500));
            }

            // Restore original states
            await restoreLightStates();
            disableEffectButtons(false);
        }

        // üï∫ DISCO - Random flashing colors
        async function discoMode() {
            if (!confirmEffect('Disco')) return;
            if (effectInProgress) return;
            effectInProgress = true;
            disableEffectButtons(true);

            const success = await saveLightStates();
            if (!success) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            const lights = await getAllLights();
            if (!lights) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            const lightIds = Object.keys(lights);

            // Random flashing for 5 seconds
            for (let i = 0; i < 20; i++) {
                // Each light gets a random color
                for (const lightId of lightIds) {
                    const randomHue = Math.floor(Math.random() * 65535);
                    const randomOn = Math.random() > 0.3; // 70% chance to be on

                    await setLightState(lightId, {
                        on: randomOn,
                        bri: randomOn ? 254 : 0,
                        hue: randomHue,
                        sat: 254,
                        transitiontime: 0
                    });
                }

                await new Promise(resolve => setTimeout(resolve, 250));
            }

            // Restore original states
            await restoreLightStates();
            disableEffectButtons(false);
        }

        // üåä WAVE - Lights turn on in sequence
        async function waveEffect() {
            if (!confirmEffect('Wave')) return;
            if (effectInProgress) return;
            effectInProgress = true;
            disableEffectButtons(true);

            const success = await saveLightStates();
            if (!success) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            const lights = await getAllLights();
            if (!lights) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            const lightIds = Object.keys(lights);

            // Turn all lights off first
            for (const lightId of lightIds) {
                await setLightState(lightId, { on: false, transitiontime: 0 });
            }

            await new Promise(resolve => setTimeout(resolve, 300));

            // Wave through lights 3 times
            for (let wave = 0; wave < 3; wave++) {
                for (const lightId of lightIds) {
                    // Turn this light on with cyan color
                    await setLightState(lightId, {
                        on: true,
                        bri: 254,
                        hue: 46920, // Cyan/Blue
                        sat: 254,
                        transitiontime: 0
                    });

                    await new Promise(resolve => setTimeout(resolve, 150));

                    // Turn it back off
                    await setLightState(lightId, { on: false, transitiontime: 2 });
                }
            }

            await new Promise(resolve => setTimeout(resolve, 500));

            // Restore original states
            await restoreLightStates();
            disableEffectButtons(false);
        }

        // üåÖ SUNSET - Gradual warm orange glow then fade
        async function sunsetMode() {
            if (!confirmEffect('Sunset')) return;
            if (effectInProgress) return;
            effectInProgress = true;
            disableEffectButtons(true);

            const success = await saveLightStates();
            if (!success) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            const lights = await getAllLights();
            if (!lights) {
                effectInProgress = false;
                disableEffectButtons(false);
                return;
            }

            // Fade to warm sunset orange
            for (const lightId of Object.keys(lights)) {
                await setLightState(lightId, {
                    on: true,
                    bri: 200,
                    hue: 5000, // Warm orange
                    sat: 200,
                    transitiontime: 30 // 3 seconds fade in
                });
            }

            await new Promise(resolve => setTimeout(resolve, 3500));

            // Hold for 2 seconds
            await new Promise(resolve => setTimeout(resolve, 2000));

            // Fade to dim
            for (const lightId of Object.keys(lights)) {
                await setLightState(lightId, {
                    on: true,
                    bri: 1,
                    transitiontime: 30 // 3 seconds fade out
                });
            }

            await new Promise(resolve => setTimeout(resolve, 3500));

            // Restore original states
            await restoreLightStates();
            disableEffectButtons(false);
        }

        // ============================================================================
        // PIXEL ART MOOSE CHARACTER SYSTEM
        // ============================================================================

        const MOOSE_CONFIG = {
            MIN_INTERVAL: 10 * 60 * 1000,      // 10 minutes
            MAX_INTERVAL: 20 * 60 * 1000,      // 20 minutes
            ENABLE_NIGHT_ACTIVITIES: true,      // Allow star gazing
            ENABLE_EFFECTS: true,               // Enable special effects
            WALK_IN_DURATION: 2000,            // Entry animation duration
            WALK_OUT_DURATION: 2000,           // Exit animation duration
            DEBUG_MODE: true,                  // Use shorter intervals for testing (CHANGE TO false FOR PRODUCTION)
        };

        // Debug mode uses 30-60 second intervals
        if (MOOSE_CONFIG.DEBUG_MODE) {
            MOOSE_CONFIG.MIN_INTERVAL = 30 * 1000;
            MOOSE_CONFIG.MAX_INTERVAL = 60 * 1000;
        }

        const mooseLocations = {
            garden: {
                tree: { x: 40, y: 480 },              // Under the tree for picnic/stargazing
                lamppost: { x: 110, y: 520 },         // By lamppost for reading
                flowers: { x: 720, y: 510 }           // Near flowers for watering
            },
            house: {
                frontDoor: { x: 160, y: 480 },        // Next to front door for painting
                window1: { x: 300, y: 380 },          // Right next to ground floor window
                window2: { x: 500, y: 380 },          // Right next to middle window
                window3: { x: 720, y: 380 },          // Right next to right window
                gardenEdge: { x: 80, y: 520 }         // On grass area for mowing
            }
        };

        const mooseActivities = [
            {
                name: 'cleaningWindows',
                locations: ['house.window1', 'house.window2', 'house.window3'],
                duration: 20000,
                emoji: 'üßΩ'
            },
            {
                name: 'mowingLawn',
                locations: ['house.gardenEdge'],
                duration: 25000,
                emoji: 'üå±'
            },
            {
                name: 'wateringPlants',
                locations: ['garden.flowers'],
                duration: 18000,
                emoji: 'üíß'
            },
            {
                name: 'havingPicnic',
                locations: ['garden.tree'],
                duration: 30000,
                emoji: 'üß∫'
            },
            {
                name: 'readingNewspaper',
                locations: ['garden.lamppost'],
                duration: 22000,
                emoji: 'üì∞'
            },
            {
                name: 'paintingHouse',
                locations: ['house.frontDoor'],
                duration: 25000,
                emoji: 'üé®'
            },
            {
                name: 'starGazing',
                locations: ['garden.tree'],
                duration: 35000,
                nightOnly: true,
                emoji: 'üî≠'
            }
        ];

        let mooseState = {
            isActive: false,
            currentActivity: null,
            nextAppearanceTime: null,
            currentTimeout: null
        };

        function createMooseCharacter(activityName, x, y) {
            const svgNS = 'http://www.w3.org/2000/svg';
            const mooseGroup = document.createElementNS(svgNS, 'g');
            mooseGroup.setAttribute('id', 'active-moose');
            mooseGroup.setAttribute('transform', `translate(${x}, ${y})`);

            // Antlers
            const antler1 = document.createElementNS(svgNS, 'rect');
            antler1.setAttribute('x', '8');
            antler1.setAttribute('y', '0');
            antler1.setAttribute('width', '12');
            antler1.setAttribute('height', '4');
            antler1.setAttribute('fill', '#654321');
            mooseGroup.appendChild(antler1);

            const antler1a = document.createElementNS(svgNS, 'rect');
            antler1a.setAttribute('x', '4');
            antler1a.setAttribute('y', '4');
            antler1a.setAttribute('width', '8');
            antler1a.setAttribute('height', '4');
            antler1a.setAttribute('fill', '#654321');
            mooseGroup.appendChild(antler1a);

            const antler2 = document.createElementNS(svgNS, 'rect');
            antler2.setAttribute('x', '28');
            antler2.setAttribute('y', '0');
            antler2.setAttribute('width', '12');
            antler2.setAttribute('height', '4');
            antler2.setAttribute('fill', '#654321');
            mooseGroup.appendChild(antler2);

            const antler2a = document.createElementNS(svgNS, 'rect');
            antler2a.setAttribute('x', '36');
            antler2a.setAttribute('y', '4');
            antler2a.setAttribute('width', '8');
            antler2a.setAttribute('height', '4');
            antler2a.setAttribute('fill', '#654321');
            mooseGroup.appendChild(antler2a);

            // Head
            const head = document.createElementNS(svgNS, 'rect');
            head.setAttribute('x', '12');
            head.setAttribute('y', '8');
            head.setAttribute('width', '24');
            head.setAttribute('height', '24');
            head.setAttribute('fill', '#8B4513');
            mooseGroup.appendChild(head);

            // Snout
            const snout = document.createElementNS(svgNS, 'rect');
            snout.setAttribute('x', '8');
            snout.setAttribute('y', '20');
            snout.setAttribute('width', '12');
            snout.setAttribute('height', '12');
            snout.setAttribute('fill', '#A0522D');
            mooseGroup.appendChild(snout);

            // Eyes
            const eye1 = document.createElementNS(svgNS, 'rect');
            eye1.setAttribute('x', '16');
            eye1.setAttribute('y', '16');
            eye1.setAttribute('width', '4');
            eye1.setAttribute('height', '4');
            eye1.setAttribute('fill', '#2C1507');
            mooseGroup.appendChild(eye1);

            const eye2 = document.createElementNS(svgNS, 'rect');
            eye2.setAttribute('x', '28');
            eye2.setAttribute('y', '16');
            eye2.setAttribute('width', '4');
            eye2.setAttribute('height', '4');
            eye2.setAttribute('fill', '#2C1507');
            mooseGroup.appendChild(eye2);

            // Nose
            const nose = document.createElementNS(svgNS, 'rect');
            nose.setAttribute('x', '8');
            nose.setAttribute('y', '24');
            nose.setAttribute('width', '4');
            nose.setAttribute('height', '4');
            nose.setAttribute('fill', '#2C1507');
            mooseGroup.appendChild(nose);

            // Body
            const body = document.createElementNS(svgNS, 'rect');
            body.setAttribute('x', '8');
            body.setAttribute('y', '32');
            body.setAttribute('width', '32');
            body.setAttribute('height', '32');
            body.setAttribute('fill', '#8B4513');
            mooseGroup.appendChild(body);

            // Legs
            const leg1 = document.createElementNS(svgNS, 'rect');
            leg1.setAttribute('x', '12');
            leg1.setAttribute('y', '64');
            leg1.setAttribute('width', '8');
            leg1.setAttribute('height', '24');
            leg1.setAttribute('fill', '#654321');
            mooseGroup.appendChild(leg1);

            const leg2 = document.createElementNS(svgNS, 'rect');
            leg2.setAttribute('x', '28');
            leg2.setAttribute('y', '64');
            leg2.setAttribute('width', '8');
            leg2.setAttribute('height', '24');
            leg2.setAttribute('fill', '#654321');
            mooseGroup.appendChild(leg2);

            // Tail
            const tail = document.createElementNS(svgNS, 'rect');
            tail.setAttribute('x', '40');
            tail.setAttribute('y', '44');
            tail.setAttribute('width', '8');
            tail.setAttribute('height', '12');
            tail.setAttribute('fill', '#654321');
            mooseGroup.appendChild(tail);

            // Add activity-specific props
            const props = getActivityProps(activityName, svgNS);
            if (props) {
                mooseGroup.appendChild(props);
            }

            // Add speech bubble (will be shown briefly)
            const speechBubble = createSpeechBubble(svgNS);
            speechBubble.setAttribute('id', 'moose-speech');
            mooseGroup.appendChild(speechBubble);

            return mooseGroup;
        }

        function createSpeechBubble(svgNS) {
            const bubbleGroup = document.createElementNS(svgNS, 'g');
            bubbleGroup.setAttribute('transform', 'translate(50, -30)');

            // Bubble background
            const bubble = document.createElementNS(svgNS, 'rect');
            bubble.setAttribute('x', '0');
            bubble.setAttribute('y', '0');
            bubble.setAttribute('width', '100');
            bubble.setAttribute('height', '32');
            bubble.setAttribute('rx', '8');
            bubble.setAttribute('fill', 'white');
            bubble.setAttribute('stroke', '#2C3E50');
            bubble.setAttribute('stroke-width', '2');
            bubbleGroup.appendChild(bubble);

            // Tail
            const tail = document.createElementNS(svgNS, 'polygon');
            tail.setAttribute('points', '20,32 15,40 30,32');
            tail.setAttribute('fill', 'white');
            tail.setAttribute('stroke', '#2C3E50');
            tail.setAttribute('stroke-width', '2');
            bubbleGroup.appendChild(tail);

            // Text
            const text = document.createElementNS(svgNS, 'text');
            text.setAttribute('x', '50');
            text.setAttribute('y', '20');
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-family', 'Arial, sans-serif');
            text.setAttribute('font-size', '12');
            text.setAttribute('font-weight', 'bold');
            text.setAttribute('fill', '#2C3E50');
            text.textContent = "It's me Monty!";
            bubbleGroup.appendChild(text);

            // Animation
            bubbleGroup.style.animation = 'speech-bubble-appear 4s ease-out forwards';

            return bubbleGroup;
        }

        function getActivityProps(activityName, svgNS) {
            const propsGroup = document.createElementNS(svgNS, 'g');
            propsGroup.setAttribute('class', 'moose-activity-prop');

            switch (activityName) {
                case 'cleaningWindows':
                    // Bucket (on ground)
                    const bucket = document.createElementNS(svgNS, 'rect');
                    bucket.setAttribute('x', '-20');
                    bucket.setAttribute('y', '70');
                    bucket.setAttribute('width', '16');
                    bucket.setAttribute('height', '16');
                    bucket.setAttribute('fill', '#4682B4');
                    propsGroup.appendChild(bucket);

                    // Handle
                    const handle = document.createElementNS(svgNS, 'rect');
                    handle.setAttribute('x', '-16');
                    handle.setAttribute('y', '68');
                    handle.setAttribute('width', '8');
                    handle.setAttribute('height', '2');
                    handle.setAttribute('fill', '#2C3E50');
                    propsGroup.appendChild(handle);

                    // Sponge (in moose's "hand")
                    const sponge = document.createElementNS(svgNS, 'rect');
                    sponge.setAttribute('x', '42');
                    sponge.setAttribute('y', '36');
                    sponge.setAttribute('width', '10');
                    sponge.setAttribute('height', '8');
                    sponge.setAttribute('fill', '#FFD700');
                    propsGroup.appendChild(sponge);
                    break;

                case 'mowingLawn':
                    // Lawn mower body
                    const mowerBody = document.createElementNS(svgNS, 'rect');
                    mowerBody.setAttribute('x', '-28');
                    mowerBody.setAttribute('y', '72');
                    mowerBody.setAttribute('width', '24');
                    mowerBody.setAttribute('height', '16');
                    mowerBody.setAttribute('fill', '#DC143C');
                    propsGroup.appendChild(mowerBody);

                    // Wheels
                    const wheel1 = document.createElementNS(svgNS, 'circle');
                    wheel1.setAttribute('cx', '-22');
                    wheel1.setAttribute('cy', '88');
                    wheel1.setAttribute('r', '4');
                    wheel1.setAttribute('fill', '#2C3E50');
                    propsGroup.appendChild(wheel1);

                    const wheel2 = document.createElementNS(svgNS, 'circle');
                    wheel2.setAttribute('cx', '-10');
                    wheel2.setAttribute('cy', '88');
                    wheel2.setAttribute('r', '4');
                    wheel2.setAttribute('fill', '#2C3E50');
                    propsGroup.appendChild(wheel2);
                    break;

                case 'wateringPlants':
                    // Watering can body
                    const canBody = document.createElementNS(svgNS, 'rect');
                    canBody.setAttribute('x', '42');
                    canBody.setAttribute('y', '38');
                    canBody.setAttribute('width', '20');
                    canBody.setAttribute('height', '14');
                    canBody.setAttribute('fill', '#5DADE2');
                    propsGroup.appendChild(canBody);

                    // Spout
                    const spout = document.createElementNS(svgNS, 'rect');
                    spout.setAttribute('x', '62');
                    spout.setAttribute('y', '44');
                    spout.setAttribute('width', '8');
                    spout.setAttribute('height', '3');
                    spout.setAttribute('fill', '#5DADE2');
                    propsGroup.appendChild(spout);

                    // Handle
                    const canHandle = document.createElementNS(svgNS, 'rect');
                    canHandle.setAttribute('x', '48');
                    canHandle.setAttribute('y', '34');
                    canHandle.setAttribute('width', '2');
                    canHandle.setAttribute('height', '8');
                    canHandle.setAttribute('fill', '#2874A6');
                    propsGroup.appendChild(canHandle);
                    break;

                case 'havingPicnic':
                    // Blanket (checkered)
                    for (let i = 0; i < 4; i++) {
                        for (let j = 0; j < 4; j++) {
                            if ((i + j) % 2 === 0) {
                                const square = document.createElementNS(svgNS, 'rect');
                                square.setAttribute('x', (50 + i * 8).toString());
                                square.setAttribute('y', (74 + j * 8).toString());
                                square.setAttribute('width', '8');
                                square.setAttribute('height', '8');
                                square.setAttribute('fill', '#E74C3C');
                                propsGroup.appendChild(square);
                            }
                        }
                    }

                    // Basket
                    const basket = document.createElementNS(svgNS, 'rect');
                    basket.setAttribute('x', '66');
                    basket.setAttribute('y', '82');
                    basket.setAttribute('width', '16');
                    basket.setAttribute('height', '12');
                    basket.setAttribute('fill', '#8B4513');
                    propsGroup.appendChild(basket);
                    break;

                case 'readingNewspaper':
                    // Newspaper
                    const paper = document.createElementNS(svgNS, 'rect');
                    paper.setAttribute('x', '46');
                    paper.setAttribute('y', '32');
                    paper.setAttribute('width', '18');
                    paper.setAttribute('height', '24');
                    paper.setAttribute('fill', '#BDC3C7');
                    propsGroup.appendChild(paper);

                    // Text lines
                    for (let i = 0; i < 5; i++) {
                        const line = document.createElementNS(svgNS, 'rect');
                        line.setAttribute('x', '48');
                        line.setAttribute('y', (36 + i * 4).toString());
                        line.setAttribute('width', '14');
                        line.setAttribute('height', '1');
                        line.setAttribute('fill', '#2C3E50');
                        propsGroup.appendChild(line);
                    }
                    break;

                case 'paintingHouse':
                    // Paint bucket
                    const paintBucket = document.createElementNS(svgNS, 'rect');
                    paintBucket.setAttribute('x', '-20');
                    paintBucket.setAttribute('y', '76');
                    paintBucket.setAttribute('width', '14');
                    paintBucket.setAttribute('height', '12');
                    paintBucket.setAttribute('fill', '#95A5A6');
                    propsGroup.appendChild(paintBucket);

                    // Paint brush
                    const brushHandle = document.createElementNS(svgNS, 'rect');
                    brushHandle.setAttribute('x', '44');
                    brushHandle.setAttribute('y', '24');
                    brushHandle.setAttribute('width', '3');
                    brushHandle.setAttribute('height', '20');
                    brushHandle.setAttribute('fill', '#8B4513');
                    propsGroup.appendChild(brushHandle);

                    const brushHead = document.createElementNS(svgNS, 'rect');
                    brushHead.setAttribute('x', '42');
                    brushHead.setAttribute('y', '44');
                    brushHead.setAttribute('width', '7');
                    brushHead.setAttribute('height', '8');
                    brushHead.setAttribute('fill', '#ECF0F1');
                    propsGroup.appendChild(brushHead);
                    break;

                case 'starGazing':
                    // Telescope
                    const telescopeStand = document.createElementNS(svgNS, 'rect');
                    telescopeStand.setAttribute('x', '58');
                    telescopeStand.setAttribute('y', '60');
                    telescopeStand.setAttribute('width', '3');
                    telescopeStand.setAttribute('height', '28');
                    telescopeStand.setAttribute('fill', '#2C3E50');
                    propsGroup.appendChild(telescopeStand);

                    const telescopeTube = document.createElementNS(svgNS, 'rect');
                    telescopeTube.setAttribute('x', '54');
                    telescopeTube.setAttribute('y', '44');
                    telescopeTube.setAttribute('width', '24');
                    telescopeTube.setAttribute('height', '6');
                    telescopeTube.setAttribute('fill', '#34495E');
                    propsGroup.appendChild(telescopeTube);
                    break;
            }

            return propsGroup;
        }

        function showMoose() {
            if (mooseState.isActive) return;

            // Select random activity
            const activity = selectRandomActivity();
            if (!activity) {
                scheduleMooseAppearance();
                return;
            }

            // Select random location for that activity
            const locationKey = activity.locations[Math.floor(Math.random() * activity.locations.length)];
            const [category, place] = locationKey.split('.');
            const location = mooseLocations[category][place];

            console.log(`ü´é Moose appearing! Activity: ${activity.name} at ${locationKey}`);

            // Monty announces his arrival!
            announceMoose();

            // Create moose with props
            const mooseElement = createMooseCharacter(activity.name, location.x, location.y);

            // Add to SVG container
            const container = document.getElementById('moose-container');
            container.appendChild(mooseElement);

            mooseState.isActive = true;
            mooseState.currentActivity = activity.name;

            // Trigger entry animation
            mooseElement.style.animation = `moose-walk-in ${MOOSE_CONFIG.WALK_IN_DURATION}ms ease-out`;

            // After entry, start activity animation
            setTimeout(() => {
                startActivityAnimation(mooseElement, activity.name, location);
            }, MOOSE_CONFIG.WALK_IN_DURATION);

            // Schedule exit
            setTimeout(() => {
                removeMoose(mooseElement);
            }, activity.duration);
        }

        function selectRandomActivity() {
            // Check if it's night (sun is hidden)
            const sun = document.getElementById('sun');
            const isNight = sun && sun.style.display === 'none';

            let available = mooseActivities.filter(a =>
                !a.nightOnly || (a.nightOnly && isNight)
            );

            if (available.length === 0) return null;

            return available[Math.floor(Math.random() * available.length)];
        }

        function startActivityAnimation(element, activityName, location) {
            const activityElement = element.querySelector('.moose-activity-prop');

            // Add gentle bobbing to moose
            element.style.animation = 'moose-bob 2s ease-in-out infinite';

            if (activityElement) {
                switch (activityName) {
                    case 'cleaningWindows':
                        activityElement.style.animation = 'window-clean 2s ease-in-out infinite';
                        // Add window brightening effect
                        if (MOOSE_CONFIG.ENABLE_EFFECTS) {
                            const windows = document.querySelectorAll('rect[fill="#87CEEB"]');
                            windows.forEach(w => {
                                w.style.animation = 'window-brighten 3s ease-in-out infinite';
                            });
                        }
                        break;
                    case 'wateringPlants':
                        activityElement.style.animation = 'water-pour 2s ease-in-out infinite';
                        // Add flower bouncing effect
                        if (MOOSE_CONFIG.ENABLE_EFFECTS) {
                            const flowers = document.querySelectorAll('g[transform*="750, 598"] circle');
                            flowers.forEach(f => {
                                f.style.animation = 'flower-bounce 1.5s ease-in-out infinite';
                            });
                        }
                        break;
                    case 'mowingLawn':
                        activityElement.style.animation = 'mow-forward 8s linear';
                        // Add grass pulsing effect
                        if (MOOSE_CONFIG.ENABLE_EFFECTS) {
                            const grass = document.querySelector('rect[fill="url(#grassGradient)"]');
                            if (grass) {
                                grass.style.animation = 'grass-pulse 2s ease-in-out infinite';
                            }
                        }
                        break;
                    case 'readingNewspaper':
                        activityElement.style.animation = 'read-newspaper 3s ease-in-out infinite';
                        break;
                    case 'paintingHouse':
                        activityElement.style.animation = 'paint-brush 1.5s ease-in-out infinite';
                        break;
                    case 'starGazing':
                        activityElement.style.animation = 'telescope-pan 4s ease-in-out alternate infinite';
                        // Enhance star twinkling
                        if (MOOSE_CONFIG.ENABLE_EFFECTS) {
                            const stars = document.querySelectorAll('circle[fill="#FFFFFF"]');
                            stars.forEach(s => {
                                s.style.filter = 'brightness(1.5)';
                            });
                        }
                        break;
                }
            }
        }

        function removeMoose(element) {
            element.style.animation = `moose-walk-out ${MOOSE_CONFIG.WALK_OUT_DURATION}ms ease-in`;

            setTimeout(() => {
                element.remove();
                mooseState.isActive = false;
                mooseState.currentActivity = null;

                // Clean up effects
                if (MOOSE_CONFIG.ENABLE_EFFECTS) {
                    const windows = document.querySelectorAll('rect[fill="#87CEEB"]');
                    windows.forEach(w => { w.style.animation = ''; });

                    const flowers = document.querySelectorAll('g[transform*="750, 598"] circle');
                    flowers.forEach(f => { f.style.animation = ''; });

                    const grass = document.querySelector('rect[fill="url(#grassGradient)"]');
                    if (grass) grass.style.animation = '';

                    const stars = document.querySelectorAll('circle[fill="#FFFFFF"]');
                    stars.forEach(s => { s.style.filter = ''; });
                }

                console.log('ü´é Moose left!');
                scheduleMooseAppearance();
            }, MOOSE_CONFIG.WALK_OUT_DURATION);
        }

        function scheduleMooseAppearance() {
            const minInterval = MOOSE_CONFIG.MIN_INTERVAL;
            const maxInterval = MOOSE_CONFIG.MAX_INTERVAL;
            const randomInterval = Math.floor(Math.random() * (maxInterval - minInterval)) + minInterval;

            mooseState.currentTimeout = setTimeout(() => {
                showMoose();
            }, randomInterval);

            mooseState.nextAppearanceTime = Date.now() + randomInterval;
            localStorage.setItem('mooseNextAppearance', mooseState.nextAppearanceTime);

            const minutes = Math.round(randomInterval / 60000);
            console.log(`ü´é Next moose appearance in ~${minutes} minutes`);
        }

        function handleVisibilityChange() {
            if (document.hidden) {
                // Page hidden - save state
                if (mooseState.currentTimeout) {
                    clearTimeout(mooseState.currentTimeout);
                    localStorage.setItem('mooseNextAppearance', mooseState.nextAppearanceTime);
                }
            } else {
                // Page visible - restore state
                const savedTime = localStorage.getItem('mooseNextAppearance');
                if (savedTime && !mooseState.isActive) {
                    const timeRemaining = parseInt(savedTime) - Date.now();
                    if (timeRemaining > 0) {
                        mooseState.currentTimeout = setTimeout(showMoose, timeRemaining);
                        const minutes = Math.round(timeRemaining / 60000);
                        console.log(`ü´é Moose will appear in ~${minutes} minutes`);
                    } else {
                        scheduleMooseAppearance();
                    }
                }
            }
        }

        function announceMoose() {
            // Use Web Speech API for Monty's voice announcement
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance();
                utterance.text = "It's me, Monty!";
                utterance.rate = 0.9;
                utterance.pitch = 1.1;
                utterance.volume = 0.8;

                // Try to use a friendly voice
                const voices = speechSynthesis.getVoices();
                const preferredVoice = voices.find(voice =>
                    voice.name.includes('Google UK English Male') ||
                    voice.name.includes('Daniel') ||
                    voice.lang.startsWith('en')
                );
                if (preferredVoice) {
                    utterance.voice = preferredVoice;
                }

                speechSynthesis.speak(utterance);
            }
        }

        function initMooseSystem() {
            console.log('ü´é Moose system initialized!');
            console.log(`   Debug mode: ${MOOSE_CONFIG.DEBUG_MODE ? 'ON (30-60 sec)' : 'OFF (10-20 min)'}`);

            // Add visibility change listener
            document.addEventListener('visibilitychange', handleVisibilityChange);

            // Schedule first appearance
            scheduleMooseAppearance();
        }

        // Initialize moose system
        initMooseSystem();

        // ============================================================================
        // GOOGLE NEST THERMOSTAT INTEGRATION
        // ============================================================================

        let nestDevices = [];
        let nestAccessToken = NEST_CONFIG?.access_token;
        let nestTokenExpiry = NEST_CONFIG?.expires_at;

        async function refreshNestToken() {
            console.log('üå°Ô∏è  Refreshing Nest access token...');

            const tokenData = new URLSearchParams({
                client_id: NEST_CONFIG.CLIENT_ID,
                client_secret: NEST_CONFIG.CLIENT_SECRET,
                refresh_token: NEST_CONFIG.refresh_token,
                grant_type: 'refresh_token'
            }).toString();

            try {
                const response = await fetch('https://www.googleapis.com/oauth2/v4/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body: tokenData
                });

                const tokens = await response.json();

                if (tokens.access_token) {
                    nestAccessToken = tokens.access_token;
                    nestTokenExpiry = Date.now() + (tokens.expires_in * 1000);
                    console.log('‚úì Nest token refreshed');
                    return true;
                } else {
                    console.error('‚úó Failed to refresh Nest token:', tokens);
                    return false;
                }
            } catch (error) {
                console.error('‚úó Error refreshing Nest token:', error);
                return false;
            }
        }

        async function fetchNestDevices() {
            // Check if token needs refresh (refresh 5 min before expiry)
            if (Date.now() > (nestTokenExpiry - 5 * 60 * 1000)) {
                const refreshed = await refreshNestToken();
                if (!refreshed) return null;
            }

            try {
                const response = await fetch(
                    `https://smartdevicemanagement.googleapis.com/v1/enterprises/${NEST_CONFIG.PROJECT_ID}/devices`,
                    {
                        headers: {
                            'Authorization': `Bearer ${nestAccessToken}`
                        }
                    }
                );

                if (!response.ok) {
                    console.error('‚úó Nest API error:', response.status);
                    return null;
                }

                const data = await response.json();
                return data.devices || [];
            } catch (error) {
                console.error('‚úó Error fetching Nest devices:', error);
                return null;
            }
        }

        async function setNestTemperature(targetTempC) {
            if (nestDevices.length === 0) {
                console.error('No Nest devices found');
                return false;
            }

            // Check if token needs refresh
            if (Date.now() > (nestTokenExpiry - 5 * 60 * 1000)) {
                const refreshed = await refreshNestToken();
                if (!refreshed) return false;
            }

            const device = nestDevices[0]; // First device
            const deviceName = device.name; // Full device resource name

            console.log(`üå°Ô∏è  Setting Nest temperature to ${targetTempC}¬∞C...`);

            try {
                const response = await fetch(
                    `https://smartdevicemanagement.googleapis.com/v1/${deviceName}:executeCommand`,
                    {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${nestAccessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            command: 'sdm.devices.commands.ThermostatTemperatureSetpoint.SetHeat',
                            params: {
                                heatCelsius: targetTempC
                            }
                        })
                    }
                );

                if (!response.ok) {
                    const error = await response.text();
                    console.error('‚úó Failed to set temperature:', error);
                    return false;
                }

                console.log(`‚úì Temperature set to ${targetTempC}¬∞C`);

                // Update display immediately
                setTimeout(updateNestDisplay, 2000);

                return true;
            } catch (error) {
                console.error('‚úó Error setting temperature:', error);
                return false;
            }
        }

        async function updateNestDisplay() {
            const devices = await fetchNestDevices();

            if (!devices || devices.length === 0) {
                return;
            }

            nestDevices = devices;

            // Update each Nest device
            devices.forEach((device, index) => {
                const tempTrait = device.traits['sdm.devices.traits.Temperature'];
                const infoTrait = device.traits['sdm.devices.traits.Info'];
                const thermostatTrait = device.traits['sdm.devices.traits.ThermostatTemperatureSetpoint'];

                if (tempTrait) {
                    const tempC = tempTrait.ambientTemperatureCelsius;
                    const deviceName = infoTrait?.customName || `Nest ${index + 1}`;

                    console.log(`üå°Ô∏è  ${deviceName}: ${tempC.toFixed(1)}¬∞C`);

                    // Display in the stats
                    displayNestInStats(deviceName, tempC, thermostatTrait);
                }
            });
        }

        function displayNestInStats(name, tempC, thermostatTrait) {
            // Check if we already have a Nest stats card
            let nestCard = document.getElementById('nest-stat-card');

            if (!nestCard) {
                // Create a new stats card for Nest
                const statsGrid = document.querySelector('.stats-grid');
                nestCard = document.createElement('div');
                nestCard.id = 'nest-stat-card';
                nestCard.className = 'stat-card';
                statsGrid.appendChild(nestCard);
            }

            let targetTemp = '';
            let targetTempValue = null;
            let status = 'OFF';
            let statusColor = 'transparent';

            if (thermostatTrait?.heatCelsius) {
                targetTemp = ` ‚Üí ${thermostatTrait.heatCelsius.toFixed(1)}¬∞C`;
                targetTempValue = thermostatTrait.heatCelsius;
                // Check if heating
                if (tempC < thermostatTrait.heatCelsius - 0.5) {
                    status = 'HEATING';
                    statusColor = '#FF6B35'; // Orange
                }
            } else if (thermostatTrait?.coolCelsius) {
                targetTemp = ` ‚Üí ${thermostatTrait.coolCelsius.toFixed(1)}¬∞C`;
                targetTempValue = thermostatTrait.coolCelsius;
                // Check if cooling
                if (tempC > thermostatTrait.coolCelsius + 0.5) {
                    status = 'COOLING';
                    statusColor = '#4ECDC4'; // Blue
                }
            }

            nestCard.innerHTML = `
                <div class="stat-label">üå°Ô∏è  ${name} (Nest)</div>
                <div class="stat-value">${tempC.toFixed(1)}¬∞C${targetTemp}</div>
            `;

            // Update the visual Nest thermostat display in the lounge
            updateNestVisualDisplay(tempC, targetTempValue, status, statusColor);
        }

        function updateNestVisualDisplay(currentTemp, targetTemp, status, statusColor) {
            const currentTempEl = document.getElementById('nest-current-temp');
            const targetTempEl = document.getElementById('nest-target-temp');
            const statusTextEl = document.getElementById('nest-status-text');
            const statusRingEl = document.getElementById('nest-status-ring');
            const displayBgEl = document.getElementById('nest-display-bg');

            if (!currentTempEl) return; // Display not ready yet

            // Update current temperature (large center number)
            currentTempEl.textContent = currentTemp.toFixed(1) + '¬∞';

            // Update target temperature (small top number)
            if (targetTemp) {
                targetTempEl.textContent = '‚Üí ' + targetTemp.toFixed(1) + '¬∞';
                targetTempEl.setAttribute('fill', '#888888');
            } else {
                targetTempEl.textContent = '';
            }

            // Update status text
            statusTextEl.textContent = status;

            // Update status ring color (heating/cooling indicator)
            statusRingEl.setAttribute('stroke', statusColor);

            // Update display background with subtle glow
            if (status === 'HEATING') {
                displayBgEl.setAttribute('fill', '#1a0f00'); // Slight orange glow
                currentTempEl.setAttribute('fill', '#FFB84D'); // Orange text
            } else if (status === 'COOLING') {
                displayBgEl.setAttribute('fill', '#001a1a'); // Slight blue glow
                currentTempEl.setAttribute('fill', '#66D9EF'); // Blue text
            } else {
                displayBgEl.setAttribute('fill', '#000000'); // Pure black
                currentTempEl.setAttribute('fill', '#FFFFFF'); // White text
            }
        }

        function initNestIntegration() {
            if (!NEST_CONFIG || !NEST_CONFIG.access_token) {
                console.log('‚ö†Ô∏è  Nest not configured. Run nest-auth.js to set up.');
                return;
            }

            console.log('üå°Ô∏è  Nest integration initialized');

            // Make Nest thermostat draggable
            const nestDisplay = document.getElementById('nest-thermostat-display');
            if (nestDisplay) {
                makeNestDraggable(nestDisplay);
            }

            // Initial fetch
            updateNestDisplay();

            // Update every 5 minutes
            setInterval(updateNestDisplay, 5 * 60 * 1000);
        }

        function makeNestDraggable(group) {
            let isDragging = false;
            let isAdjustingTemp = false;
            let startX, startY, currentTransform;
            let startTemp, currentAdjustedTemp;

            group.style.cursor = 'pointer';

            // Load saved position from localStorage
            const savedPosition = localStorage.getItem('nestThermostatPosition');
            if (savedPosition) {
                const pos = JSON.parse(savedPosition);
                group.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);
            }

            // Get current target temperature from device
            function getCurrentTargetTemp() {
                if (nestDevices.length === 0) return 21; // Default
                const device = nestDevices[0];
                const thermostatTrait = device.traits['sdm.devices.traits.ThermostatTemperatureSetpoint'];
                return thermostatTrait?.heatCelsius || thermostatTrait?.coolCelsius || 21;
            }

            // Unified start handler for both mouse and touch
            function handleStart(e) {
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                startX = clientX;
                startY = clientY;

                // Check if Shift key is pressed for position dragging
                if (e.shiftKey) {
                    isDragging = true;
                    const transform = group.getAttribute('transform');
                    const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                    currentTransform = {
                        x: parseFloat(match[1]),
                        y: parseFloat(match[2])
                    };
                    group.style.cursor = 'move';
                    group.style.opacity = '0.7';
                } else {
                    // Temperature adjustment mode (default)
                    isAdjustingTemp = true;
                    startTemp = getCurrentTargetTemp();
                    currentAdjustedTemp = startTemp;

                    // Visual feedback
                    const statusRing = document.getElementById('nest-status-ring');
                    if (statusRing) {
                        statusRing.setAttribute('stroke', '#4A90E2');
                        statusRing.setAttribute('opacity', '0.8');
                    }
                }

                e.preventDefault();
                e.stopPropagation();
            }

            // Unified move handler
            function handleMove(e) {
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                if (isDragging) {
                    // Position dragging (Shift+drag)
                    const dx = clientX - startX;
                    const dy = clientY - startY;
                    const newX = currentTransform.x + dx;
                    const newY = currentTransform.y + dy;
                    group.setAttribute('transform', `translate(${newX}, ${newY})`);
                } else if (isAdjustingTemp) {
                    // Temperature adjustment (normal drag)
                    const dy = startY - clientY; // Inverted: drag up = increase

                    // Each 10 pixels of drag = 0.5¬∞C change
                    const tempChange = Math.round(dy / 10) * 0.5;
                    currentAdjustedTemp = Math.max(10, Math.min(30, startTemp + tempChange));

                    // Update display in real-time
                    const targetTempEl = document.getElementById('nest-target-temp');
                    const currentTempEl = document.getElementById('nest-current-temp');
                    if (targetTempEl && currentTempEl) {
                        targetTempEl.textContent = `SET: ${currentAdjustedTemp.toFixed(1)}¬∞C`;
                        targetTempEl.setAttribute('fill', '#4A90E2');
                        targetTempEl.setAttribute('font-size', '12');
                        currentTempEl.setAttribute('font-size', '24'); // Make current temp smaller
                    }
                }
            }

            // Unified end handler
            async function handleEnd(e) {
                if (isDragging) {
                    // Save position
                    isDragging = false;
                    group.style.opacity = '1';
                    group.style.cursor = 'pointer';

                    const transform = group.getAttribute('transform');
                    const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                    const position = {
                        x: parseFloat(match[1]),
                        y: parseFloat(match[2])
                    };
                    localStorage.setItem('nestThermostatPosition', JSON.stringify(position));
                    console.log('üå°Ô∏è  Nest position saved:', position);
                } else if (isAdjustingTemp) {
                    // Apply temperature change
                    isAdjustingTemp = false;

                    // Reset visual feedback
                    const statusRing = document.getElementById('nest-status-ring');
                    if (statusRing) {
                        statusRing.setAttribute('opacity', '0.6');
                    }

                    // Only send command if temperature actually changed
                    if (Math.abs(currentAdjustedTemp - startTemp) >= 0.5) {
                        console.log(`üå°Ô∏è  Setting Nest temperature to ${currentAdjustedTemp}¬∞C`);
                        await setNestTemperature(currentAdjustedTemp);
                    } else {
                        // No change, restore display
                        updateNestDisplay();
                    }
                }
            }

            // Add both mouse and touch event listeners
            group.addEventListener('mousedown', handleStart);
            group.addEventListener('touchstart', handleStart, { passive: false });

            document.addEventListener('mousemove', handleMove);
            document.addEventListener('touchmove', handleMove, { passive: false });

            document.addEventListener('mouseup', handleEnd);
            document.addEventListener('touchend', handleEnd);
        }

        // Initialize Nest integration
        initNestIntegration();

        // Expose Nest control function globally for console access
        window.setNestTemp = setNestTemperature;
    </script>

    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then((registration) => {
                        console.log('Service Worker registered successfully:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('Service Worker registration failed:', error);
                    });
            });
        }
    </script>
</body>
</html>
